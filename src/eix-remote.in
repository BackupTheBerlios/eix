#! /usr/bin/env sh
# This script is part of the eix project and distributed under the
# terms of the GNU General Public License v2.
#
# Author and Copyright (c):
#   Martin V\"ath <vaeth@mathematik.uni-wuerzburg.de>
#
# It can be used to fetch the "standard" overlay data and add it to the
# eix database. (@PACKAGE_STRING@).

. ./eix-functions.sh.in
ReadFunctions

addr='http://dev.gentooexperimental.org/eix_cache/eix-caches.tbz2'

local_portage_configroot="`eix-update --print PORTAGE_CONFIGROOT`"
eixremoteconf="${local_portage_configroot}/etc/eix-remote.conf"

Usage () {
	local n p f
	n="${0##*/}"
	p='@PACKAGE_STRING@'
	f="${filearg:-(none)}"
	eval_gettext 'Usage: ${n} [options] command [FILE]
Get data from a remote datebase for ${p}.
The following commands are provided:

update: Fetch the eix-caches of some layman overlays into a temporary file
        resp. into FILE and add them to the eix database.
        To keep this data across eix-update calls, you might want to set
        KEEP_VIRTUALS=true in /etc/eixrc (or in ~/.eixrc)
fetch:  Only fetch the overlays into FILE.
add:    Only add the overlays from FILE to the eix database.
remove: Remove all temporarily added virtual overlays from the eix database;
        this is similar to
        	KEEP_VIRTUALS=false eix-update
        but faster (without actual updating where possible).

It is strongly recommended to use the update/fetch commands with very limited
permissions. Permissions are dropped when run as root or with the "-u nobody"
option. Do not use "-u root"!

For "update" and "add" all corresponding local layman overlay paths are
excluded from the update of the current database to avoid confusion.
These local paths are determined by prefixing the path
	${LOCAL_LAYMAN}
You can modify this value with the -l option or by setting the environment
variable LOCAL_LAYMAN. If you do not want this feature (i.e. if you want
to see your local layman overlays and the remote layman overlays),
use here some path not containing any overlays (usually "/" will do).

Options can be specified in the eix (or environment) variable EIX_REMOTE_OPTS.
This data is evalued, so be aware of security risks.
Moreover, "--" in this variable will exclude further command line options.
The following options are available:

-f FILE This is the same as giving FILE as the last argument.
        This is mainly useful for default options. Current value:
        ${f}
-u USER Call wget as USER. Ignored if not set unless you are root.
-U USER Call wget as USER if called as root. Currently "${fetchroot}"
-l PATH Use PATH as LOCAL_LAYMAN
-a ADDR Use ADDR as remote database address. Current value:
        ${addr}
-i      Ignore all previous options (e.g. of local defaults).
-v      Verbose (default)
-q      Quiet'
	echo
	exitcode=${1:-1}
	exit ${exitcode}
}

SanitizeLocalLayman () {
	have_readlink=false NormalizeNames LOCAL_LAYMAN \
		|| die "`gettext '$LOCAL_LAYMAN must not be empty'`"
	[ -z "${relative}" ] || \
		die "`gettext '$LOCAL_LAYMAN must start with /'`"
}

PrintLaymanStorage () {
	python -c "from layman.config import Config
print Config()['storage']" "${@}" 2>/dev/null
}

SetLocalLayman () {
	local i
	for i
	do
		[ -n "${i}" ] && test -d "${i}" && LOCAL_LAYMAN="${i}" \
			&& return
	done
	return 1
}

InitLocalLayman () {
	local l
	[ -n "${LOCAL_LAYMAN}" ] && return
	l="`PrintLaymanStorage`" || l=''
	SetLocalLayman "${l}" \
		'/usr/local/portage/layman' \
		"${local_portdir:-/}local/layman/make.conf"
}

DefaultOpts () {
	verbose=true
	fetchuser=''
	fetchroot='nobody'
	filearg=''
}

InitLocalLayman
SanitizeLocalLayman
DefaultOpts

eval "Push -c opt `eix-update --print EIX_REMOTE_OPTS`"
Push opt "${@}"
eval "set -- ${opt}"
OPTIND=1
while getopts 'f:vqu:U:l:a:i?hH' opt
do
	case "${opt}" in
		f) filearg="${OPTARG}";;
		v) verbose=true;;
		q) verbose=false;;
		u) fetchuser="${OPTARG}";;
		U) fetchroot="${OPTARG}";;
		l) LOCAL_LAYMAN="${OPTARG}"; SanitizeLocalLayman;;
		a) addr="${OPTARG}";;
		i) DefaultOpts;;
		*) Usage 0;;
	esac
done
opt=''
[ ${OPTIND} -gt 1 ] && shift "`expr ${OPTIND} - 1`"

need_arg=false
GetFilename () {
	[ ${#} -gt 1 ] && Usage
	if [ ${#} -lt 1 ]
	then
		filename="${filearg}"
	else
		filename="${1}"
	fi
	if [ -z "${filename}" ]; then
				return
	fi
	case "${filename}" in
		'') ${need_arg} &&
			die "`gettext 'Filename argument is mandatory'`";;
		/*|'~'*) :;;
		*) filename="`pwd`/${filename}";;
	esac
}

CalcSuCmd () {
	local shexec a
	if [ -z "${fetchuser}" ]
	then
		[ -n "${UID}" ] || UID="`id -u`"
		if [ "${UID}" -ne 0 ]; then
			Push -c sucmd "${@}"
			return
		fi
		fetchuser=${fetchroot}
	fi
	shexec="${SHELL}"
	if [ -z "${shexec}" ] || ! test -x "${SHELL}"
	then
		shexec="`command -v sh`" && test -x "${shexec}" || \
			shexec='/bin/sh'
	fi
	a="${1}"
	sucmd=`command -v "${a}"` && test -x "${sucmd}" || \
		die "`eval_gettext '${a} cannot be found in PATH'`"
	Push -c sucmd "${sucmd}"
	shift
	Push sucmd "${@}"
	Push -c sucmd '/bin/su' '-s' "${shexec}" '-c' \
		"eval exec ${sucmd}" "${fetchuser}"
}

CdDir () {
	local a
	cd -- "${1}" >/dev/null && return
	a="${1}"
	die "`eval_gettext 'cannot cd to ${a}'`"
}

tmpdir=''
exitcode=0
Cleanup () {
	cd / >/dev/null
	if [ -n "${tmpdir}" ]
	then
		test -d "${tmpdir}" && rm -rf -- "${tmpdir}"
	fi
	tmpdir=''
	trap - EXIT HUP INT TERM
	exit "${exitcode}"
}
MakeTempDir () {
	local count
	[ -n "${tmpdir}" ] && return
	if command -v mktemp >/dev/null 2>&1
	then
		tmpdir=`mktemp -d "/tmp/${0##*/}.XXXXXXXX"` || \
			die "`gettext 'cannot create temporary directory'`"
	else
		count=0
		while true; do
			[ ${count} -eq 9999 ] && die "`gettext \
				'found no free tempname after 10000 attempts'`"
			count="`expr ${count} + 1`"
			tmpdir="/tmp/${0##*/}.$$.${RANDOM}.${count}.${RANDOM}"
			test -e "${tmpdir}" && continue
			mkdir "${tmpdir}" || die "`eval_gettext \
				'cannot create temporary dir ${tmpdir}'`"
			break
		done
	fi
	trap Cleanup EXIT HUP INT TERM
	chmod -- 755 "${tmpdir}"
	[ -z "${1}" ] || CdDir "${tmpdir}"
}

tmpsub=''
MakeTempSub () {
	if [ -z "${tmpsub}" ]
	then
		MakeTempDir
		tmpsub="${tmpdir}/1"
		( umask 000; mkdir -- "${tmpsub}" )
	fi
	[ -z "${1}" ] || CdDir "${tmpsub}"
}

tmpfile=''
FetchTemp () {
	local eixcachesname
	eixcachesname="${addr##*/}"
	MakeTempDir cd
	tmpfile="${tmpdir}/${eixcachesname}"
	( umask 000; : >"${tmpfile}" )
	CalcSuCmd wget -c "${addr}"
	eval "set -- ${sucmd}"
	RunCommand "`eval_gettext 'Fetching ${eixcachesname}'`" "${@}" || \
		die "`eval_gettext 'could not fetch ${addr}'`"
}

AddArchive () {
	local i p l n name virtual overlayarg
	i="${1}"
	RunCommand "Unpacking data" tar xjf "${i}" || \
		die "`eval_gettext 'cannot unpack ${i}'`"
	ClearUpdateArgs
	AddLocalMethods
	for i in *
	do
		n="${i%.eix}"
		while true; do
			case "${n}" in
				_*) n="${n#_}";;
				*_*_*_*) n="${n#*_}";;
				*) break;;
			esac
		done
		Replace -g n '_' '?'
		n="*/${n}"
		p="${2}/${i}"
		name=`EIX_CACHEFILE="${p}" eix --print-overlay-path "${n}"` \
			&& [ -n "${name}" ] || {
			printf '%s\n' "`eval_gettext '${i} is broken'`" >&2
			continue
		}
		l=`EIX_CACHEFILE="${p}" eix --print-overlay-label "${n}"` || \
			l=''
		[ -z "${l}" ] && l='(no repo_name)'
		name="${name##*/}"
		virtual="layman/${name}"
		printf '%s -> %s\n' "${virtual}" "${l}"
		[ "${l}" = "${name}" ] || virtual="${virtual}: ${l}"
		Replace -g p '\' '\\'
		Replace -g p ':' '\:'
		AddMethod "${virtual}" "eix*:${p}:${n}"
		AddOverlays "${virtual}"
		AddExcludes "${LOCAL_LAYMAN}/${name}"
	done
	export KEEP_VIRTUALS=true
	CallUpdate
}

FetchCopy () {
	GetFilename "${@}"
	FetchTemp
	[ -z "${filename}" ] && return
	(
		[ "${UID}" -eq 0 ] && umask 002
		cp --preserve=timestamps -- "${tmpfile}" "${filename}"
	)
	[ "${UID}" -eq 0 ] && chown -- portage:portage "${filename}"
}

Fetch () {
	need_arg=true
	FetchCopy "${@}"
}

Add () {
	need_arg=true
	GetFilename "${@}"
	test -r "${filename}" || \
		die "`eval_gettext 'cannot read ${filename}'`"
	MakeTempDir cd
	AddArchive "${filename}" "${tmpdir}"
}

Remove () {
	ClearUpdateArgs
	AddLocalMethods
	export KEEP_VIRTUALS=false
	CallUpdate
}

Update () {
	FetchCopy "${@}"
	MakeTempSub cd
	AddArchive "${tmpfile}" "${tmpsub}"
}

main_command="${1}"
[ ${#} -gt 0 ] && shift

[ -n "${UID}" ] || UID="`id -u`"

case "${main_command}" in
	update|both)        Update "${@}";;
	fetch*|get|wget)    Fetch "${@}";;
	add*)               Add "${@}";;
	rem*|del*|rm*|sub*) Remove "${@}";;
	*)                  Usage;;
esac

exit 0
