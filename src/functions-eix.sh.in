#! /usr/bin/env sh
# This script is part of the eix project and distributed under the
# terms of the GNU General Public License v2.
#
# Author and Copyright (c):
#   Martin V\"ath <vaeth@mathematik.uni-wuerzburg.de>
#
# This file must be "source"d by POSIX scripts.
#
# It contains helper functions for update-eix-remote, update-eix-layman,
# and perhaps similar local scripts. (@PACKAGE_STRING@).

LOCAL_EPREFIX_PORTAGE_EXEC="`update-eix --print EPREFIX_PORTAGE_EXEC`"

# This must happen in a function to enforce an empty argument list.
read_functions () {
	local I
	for I in "${LOCAL_EPREFIX_PORTAGE_EXEC}/etc/init.d/functions.sh" \
		"${LOCAL_EPREFIX_PORTAGE_EXEC}/sbin/functions.sh"
	do
		test -r "${I}" || continue
		. "${I}"
		return
	done
	printf "%s: %s" "${0##*/}" "cannot read functions.sh" >&2
	exit 2
}

die () {
	eerror "${*}"
	EXITCODE=2
	exit "${EXITCODE}"
}

LOCAL_PORTDIR=''
GetPortdir () {
	[ -n "${LOCAL_PORTDIR}" ] && return
	LOCAL_PORTDIR="`update-eix --print PORTDIR`"
}

VERBOSE=true

RunCommand () {
	if ${VERBOSE}
	then
		einfo "${1}"
		shift
		"${@}"
		return ${?}
	fi
	local RET
	ebegin "${1}"
	shift
	"${@}" >/dev/null
	RET=${?}
	eend ${RET} "Problems running ${@}"
	return ${RET}
}

( eval '[ "$(( 0 + 1 ))" = 1 ]' ) >/dev/null 2>&1 && eval '
expr () {
	echo "$(( ${1} ${2} ${3} ))"
}'

# Usage: Replace [-g] VAR Search Replace
# Option -g means: Replace all occurrences
# Exit status is the number of replacements (or 127 if there are more)
Replace () {
	local ReplaceA_='' ReplaceB_ ReplaceC_=''
	case "${1}" in
		-*) ReplaceC_=0; shift;;
	esac
	eval "while {
		ReplaceB_=\${${1}%%\"\$2\"*}
		[ \"\${ReplaceB_}\" != \"\${${1}}\" ]
	}
	do
		ReplaceA_=\"\${ReplaceA_}\${ReplaceB_}\${3}\"
		${1}=\${${1}#*\"\$2\"}
		if [ -z \"\${ReplaceC_}\" ]; then
			${1}=\"\${ReplaceA_}\${${1}}\"
			return 1
		fi
		[ \${ReplaceC_} -ge 127 ] || \
			ReplaceC_=\`expr \${ReplaceC_} + 1\`
	done
	${1}=\"\${ReplaceA_}\${${1}}\""
	return ${ReplaceC_}
}

# Usage: Push [-c] VAR Args
# Append all Args to VAR, quoted such that
#    eval "${VAR}" is 'safe' and groups Args correctly.
# With option -c, VAR is cleaned in advance.
Push () {
	case "${1}" in
		-*) shift; eval "${1}=''";;
	esac
	local PushA_="${1}" PushB_
	shift
	eval "for PushB_; do
		Replace -g PushB_ \"'\" \"'\\\\''\"
		if [ -z \"\${${PushA_}}\" ]; then
			${PushA_}=\"'\${PushB_}'\"
		else
			${PushA_}=\"\${${PushA_}} '\${PushB_}'\"
		fi
	done"
}

AddUpdateArgs () {
	Push UPDATE_EIX_ARGS "${@}"
}

AddUpdateQuoting () {
	local K="$1"
	shift
	Replace -g K '?' '\?'
	Replace -g K '*' '\*'
	Replace -g K '[' '\['
	AddUpdateArgs "${K}" "${@}"
}

AddMethod () {
	AddUpdateArgs '-m'
	AddUpdateQuoting "${1}" "${2}"
}

AddOverlays () {
	local J
	for J
	do
		AddUpdateArgs '-a' "${J}"
	done
}

AddExcludes () {
	local J
	for J
	do
		AddUpdateArgs '-x'
		AddUpdateQuoting "${J}"
	done
}

ClearUpdateEixArgs () {
	UPDATE_EIX_ARGS=''
}

CallUpdateEix () {
	eval "set -- ${UPDATE_EIX_ARGS}"
	RunCommand "Calling update-eix" update-eix "${@}" || \
		die "update-eix failed"
}

AddLocalMethods () {
	local I L
	GetPortdir
	AddMethod "${LOCAL_PORTDIR}" "eix"
	for I in `portageq portdir_overlay` ${ADD_OVERLAY}
	do
		L="${I}"
		Replace -g L '\' '\\'
		Replace -g L ':' '\:'
		AddMethod "${I}" "eix::${L}"
	done
}

# Remove optional trailing newline from all variables (arguments).
# This is necessary as some shells won't take ${Var%"[newline]"}
NEWLINE_STRING='
'
Chomp () {
	local ChompA_ ChompB_ ChompC_
	for ChompA_; do
		eval "ChompB_=\"\${${ChompA_}}\""
		ChompC_="${ChompB_%?}"
		[ "${ChompC_}${NEWLINE_STRING}" = "${ChompB_}" ] &&
			eval "${ChompA_}=\"\${ChompC_}\""
	done
	true
}

# Consider variables (arguments) as paths and normalize them.
# If HAVE_READLINK=true (if possible), use readlink to resolve to "true"
# pathnames.
# Return with 1 if at least one variable is empty.
# Set RELATIVE to a list of all variables which are relative paths
# (the first token in RELATIVE will be a space if the list is not empty).

HAVE_READLINK=false
command -v readlink >/dev/null 2>&1 && HAVE_READLINK=true
NormalizeNames () {
	local NormA_ NormB_ NormC_ NormD_=0
	RELATIVE=''
	for NormC_; do
		eval "NormA_=\"\${${NormC_}}\""
		if [ -z "${NormA_}" ]; then
			NormD_=1
			continue
		fi
		case "${NormA_}" in
			/*) :;;
			*) RELATIVE="${RELATIVE} ${NormC_}";;
		esac
		if ${HAVE_READLINK}; then
			# Append A to avoid loss of trailing \n in `...`
			NormB_=`readlink -f -- "${NormA_}" ; printf A` && \
				NormB_="${NormB_%A}" && Chomp NormB_ && \
				[ -n "${NormB_}" ] && \
					NormA_="${NormB_}"
		fi
		eval "${NormC_}=\"\${NormA_}\""
		while ! Replace -g "${NormC_}" '//' '/'; do
			:
		done
		eval "[ \"\${${NormC_}}\" = '/' ] || \
			${NormC_}=\"\${${NormC_}%/}\""
	done
	return ${NormD_}
}
