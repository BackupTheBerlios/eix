#! /usr/bin/env sh

export LC_ALL=C

to_classname () {
	local i j
	case "$1" in
		port*2.1*) i=port2_1_2_;;
		*) i="$1";;
	esac
	j="${i#?}"
	printf "%s" "${i%${j}}" | tr 'a-z' 'A-Z'
	echo "${j}Cache"
}

cache_stars="sqlite"
cache_plain="sqlite cdb"
cache_vary="eix metadata"
cache_includes="parse eixcache metadata $cache_plain"
if [ "${1}" = "portage-2.1.2" ]
then
	cache_includes="$cache_includes port2_1_2"
	cache_names="$cache_names portage-2.1.2 portage-2.1"
fi

cat<<END
// AUTOGENERATED BY MAKE .. DO NOT EDIT!

#include "cache_map.h"
#include <cstddef>
END

for cache_name in $cache_includes
do
	cat<<END
#include "$cache_name/$cache_name.h"
END
done

cat<<END

#include <string>

class BasicCache;

using namespace std;
BasicCache *get_cache(const string &name, const string &appending) {
END

for cache_name in $cache_plain
do
	cache_class=`to_classname "$cache_name"`
	cat<<END
	if(name == "$cache_name")
		return new $cache_class;
END
done
for cache_name in $cache_stars
do
	cache_class=`to_classname "$cache_name"`
	cat<<END
	if(name == "${cache_name}*")
		return new $cache_class(true);
END
done
cat<<END
	{
		ParseCache *p(new ParseCache);
		if(p->initialize(name + appending))
			return p;
		delete p;
	}
END
for cache_name in $cache_vary
do
	cache_class=`to_classname "$cache_name"`
	cat<<END
	{
		$cache_class *p(new $cache_class);
		if(p->initialize(name))
			return p;
		delete p;
	}
END
done
cat <<END
	return NULL;
}
END
