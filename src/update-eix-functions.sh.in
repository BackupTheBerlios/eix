#! /bin/sh
# This script is part of the eix project and distributed under the
# terms of the GNU General Public License v2.
#
# Author and Copyright (c):
#   Martin Väth <vaeth@mathematik.uni-wuerzburg.de>
#
# This file must be "source"d by POSIX scripts.
#
# It contains helper functions for update-eix-remote, update-eix-layman,
# and perhaps similar local scripts. (@PACKAGE_STRING@).

LOCAL_EPREFIX_PORTAGE_EXEC="$(update-eix --print EPREFIX_PORTAGE_EXEC)"

if test -r "${LOCAL_EPREFIX_PORTAGE_EXEC}/etc/init.d/functions.sh"; then
	. "${LOCAL_EPREFIX_PORTAGE_EXEC}/etc/init.d/functions.sh"
elif test -r "${LOCAL_EPREFIX_PORTAGE_EXEC}/sbin/functions.sh"; then
	. "${LOCAL_EPREFIX_PORTAGE_EXEC}/sbin/functions.sh"
else
	echo "${0##*/}: Cannot read functions.sh" >&2
	exit 2
fi

die () {
	eerror "${*}"
	EXITCODE=2
	exit "${EXITCODE}"
}

LOCAL_PORTDIR=''
GetPortdir () {
	[ -n "${LOCAL_PORTDIR}" ] && return
	LOCAL_PORTDIR="$(update-eix --print PORTDIR)"
}

VERBOSE=true

RunCommand () {
	local RET
	if ${VERBOSE}; then
		einfo "${1}"
		shift
		"${@}"
		return ${?}
	fi
	ebegin "${1}"
	shift
	"${@}" >/dev/null 2>&1
	RET=${?}
	eend ${RET} "Problems running ${@}"
	return ${RET}
}

SedVar() {
	local V_="${1}" A_
	shift
	eval "A_=\"\${${V_}}\""
	A_="$(echo "X${A_}X" | sed -e '1s/^X//' -e '$s/X$//' "${@}" \
		-e "s/'/'\\\\''/g" -e "1s/^/'/" -e "\$s/\$/'/")"
	eval "${V_}=${A_}"
}

Push() {
	local A_='' S_='' V_="${1}" I_
	shift
	case "${V_}" in
		-*) V_="${1}"; shift; eval "${V_}=''";;
	esac
	for I_; do
		A_="${A_}${S_}$(echo "X${I_}X" | \
			sed -e "s/'/'\\\\''/g" -e "1s/^X/'/" -e "\$s/X\$/'/")"
		S_=' '
	done
	[ -z "${S_}" ] && return
	eval "[ -z \"\${${V_}}\" ]" && S_=''
	eval "${V_}=\"\${${V_}}\${S_}\${A_}\""
}

AddUpdateArgs() {
	Push UPDATE_EIX_ARGS "${@}"
}

AddUpdateQuoting() {
	local K="$1"
	shift
	SedVar K -e 's/\([?*[]\)/\\\1/g'
	AddUpdateArgs "${K}" "${@}"
}

AddMethod() {
	AddUpdateArgs '-m'
	AddUpdateQuoting "${1}" "${2}"
}

AddOverlays() {
	local J
	for J; do
		AddUpdateArgs '-a' "${J}"
	done
}

AddExcludes() {
	local J
	for J; do
		AddUpdateArgs '-x'
		AddUpdateQuoting "${J}"
	done
}

ClearUpdateEixArgs () {
	UPDATE_EIX_ARGS=''
}

CallUpdateEix() {
	eval "set -- ${UPDATE_EIX_ARGS}"
	RunCommand "Calling update-eix" update-eix "$@" || \
		die "update-eix failed"
}

AddLocalMethods() {
	local I
	GetPortdir
	AddMethod "${LOCAL_PORTDIR}" "eix"
	for I in $(portageq portdir_overlay) $ADD_OVERLAY
	do
		AddMethod "${I}" "eix::${I}"
	done
}

# Consider variables (arguments) as paths and normalize them.
# If READLINK=readlink (default), resolve even to "true" pathnames.
# Return with 1 if at least one variable is empty.
# Set RELATIVE to a list of all variables which are relative paths
# (the first token in RELATIVE will be a space if the list is not empty).

HAVE_READLINK=false
command -v readlink >/dev/null 2>&1 && HAVE_READLINK=true
NormalizeNames () {
	local T_ N_ I_ S_=0
	RELATIVE=''
	for I_; do
		eval "T_=\"\${${I_}}\""
		if [ -z "${T_}" ]; then
			S_=1
			continue
		fi
		case "${T_}" in
			/*) :;;
			*) RELATIVE="${RELATIVE} ${I_}";;
		esac
		if ${HAVE_READLINK}; then
			N_="$(readlink -f -- "${T_}")" && [ -n "${N_}" ] && \
				T_="${N_}"
		fi
		eval "${I_}=\"\${T_}\""
		SedVar "${I_}" -e 's://*:/:g'
		eval "[ \"\${${I_}}\" = '/' ] || ${I_}=\"\${${I_}%/}\""
	done
	return ${S_}
}

