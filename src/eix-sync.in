#!/bin/bash
# Authors: Emil Beinroth <emilbeinroth@gmx.net>
#          Martin Väth <vaeth@mathematik.uni-wuerzburg.de>

###########################################################################
#   eix is a small utility for searching ebuilds in the                   #
#   Gentoo Linux portage system. It uses indexing to allow quick searches #
#   in package descriptions with regular expressions.                     #
#                                                                         #
#   https://sourceforge.net/projects/eix                                  #
#                                                                         #
#   Copyright (c)                                                         #
#     Wolfgang Frisch <xororand@users.sourceforge.net>                    #
#     Emil Beinroth <emilbeinroth@gmx.net>                                #
#     Martin Väth <vaeth@mathematik.uni-wuerzburg.de>                     #
#                                                                         #
#   This program is free software; you can redistribute it and/or modify  #
#   it under the terms of the GNU General Public License as published by  #
#   the Free Software Foundation; either version 2 of the License, or     #
#   (at your option) any later version.                                   #
#                                                                         #
#   This program is distributed in the hope that it will be useful,       #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#   GNU General Public License for more details.                          #
#                                                                         #
#   You should have received a copy of the GNU General Public License     #
#   along with this program; if not, write to the                         #
#   Free Software Foundation, Inc.,                                       #
#   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             #
###########################################################################

source update-eix-functions.sh.in

LOCAL_VARCACHE="$(update-eix --print EPREFIX_PORTAGE_CACHE)"
EIXCACHE="$(update-eix --print EIX_CACHEFILE)"
EIXPREVIOUS="${EIXCACHE}.previous"
LOCAL_PORTAGE_CONFIGROOT="$(update-eix --print PORTAGE_CONFIGROOT)"
LAYMANCONF="${LOCAL_PORTAGE_CONFIGROOT}/etc/eix-sync.conf"
LOGFILE="${LOCAL_EPREFIX_PORTAGE_EXEC}/var/log/eix-sync.log"
PMOD="${LOCAL_PORTAGE_CONFIGROOT}/etc/portage/modules"
MODULENAME='cache.metadata_overlay.database'

Usage () {
  echo "${0##*/} [options]
Call layman/emerge --sync/--metadata and/or show updates. (@PACKAGE_STRING@)

Unless the -v option is used, the output of most commands is redirected to
    ${LOGFILE}.
Unless the -t option is used, the old database will be saved to
    ${EIXPREVIOUS}.

The file ${LAYMANCONF} determines for which overlays layman is called.
You can also add certain hooks in that file - \"man eix\" for details.

The file ${LAYMANCONF} and the environment variable EIX_SYNC_OPTS can
contain default options which are processed before the command line options.
Note that \"--\" in the default options will forbid command line options.
The following options are available:

-i   Ignore all previous options (useful to ignore the default options).
-d   Only show differences to the previously saved database and exit.
     This is equivalent to diff-eix ${EIXPREVIOUS}.
-s [USER@]SERVER[:DIR] Sync via rsync from SERVER. This option implies -m.
     USER defaults to current user and DIR defaults to \$PORTDIR
-2 [USER@]CLIENT[:DIR] Sync via rsync *to* CLIENT after successfull syncing;
     you should later call eix-sync -u locally on CLIENT.
     If you already have synced you might want to combine this option with -uU.
-U   Do not touch the database and omit the hooks after update-eix (@ entries)
     and do not show differences. This option implies -R
-u   Update database only and show differences. This is equivalent to -l@ms ''
-l   Do not call layman (and the !commands in ${LAYMANCONF}).
     However, the postponed hooks (@ and @@ entries) will be executed anyway.
-@   Do not execute the hooks (@ and @@ entries) of ${LAYMANCONF}.
-S   Do not execute the hooks after emerge --sync (@@ entries).
-m   Run emerge --metadata but not emerge --sync.
     emerge --metadata is skipped if you use portage's metadata overlay module
     or if option -U is used.
-M   Run emerge --metadata in addition to emerge --sync.
     This is probably only useful in conjunction with -c.
-t   Use temporary file to save the current database (-d will not be possible).
-v   Don't suppress output of update-eix and emerge.
-q   Be quiet (close stdout).
-w   Run emerge-webrsync instead of emerge --sync.
-W   Run emerge-delta-webrsync instead of emerge --sync.
-c CMD Run CMD instead of emerge --sync.
-C OPT Add OPT to the emerge --sync command (or whatever is used instead).
-r   Really recreate the dep-cache (rm -rf ${LOCAL_VARCACHE}/var/cache/edb/dep/*) (default).
-R   Do not really recreate the dep-cache.
-e   Skip heuristic tests whether you must be root.
-h   Show this text and exit."
  EXITCODE=${1}
  exit ${1}
}

DiffOnly() {
  [[ -e "${EIXPREVIOUS}" ]] || die "No previous database ${EIXPREVIOUS} exists"
  exec diff-eix -- "${EIXPREVIOUS}"
  die "Could not execute diff-eix"
}

if [[ -r "${LAYMANCONF}" ]]; then
  HAVECONF=1
else
  HAVECONF=''
fi
declare -a AFTER_SYNC AFTER_UPDATE BEFORE_RSYNC
ExecuteConfig () {
  local I J MYCMD
  AFTER_SYNC=()
  AFTER_UPDATE=()
  BEFORE_RSYNC=()
  CONFIG_OPTS=''
  [[ "${HAVECONF}" ]] || return
  while read I; do
    J="${I%%#*}"
    while [[ "${J% }" != "${J}" ]]; do J="${J%?}"; done
    while [[ "${J:0:1}" = " " ]]; do J="${J#?}"; done
    [[ "${J}" ]] || continue
    case "${J}" in
      !*)  J="${J#?}"; MYCMD='!';;
      @@*) J="${J#??}"; MYCMD='@@';;
      @*)  J="${J#?}"; MYCMD='@';;
      \~*) J="${J#?}"; MYCMD='~';;
      -*)  CONFIG_OPTS="${CONFIG_OPTS} ${J}"; continue;;
      *)   MYCMD="layman";;
    esac
    [[ "${1}" = 'opts' ]] && continue
    case "${MYCMD}" in
      @@) Push AFTER_UPDATE "${J}"; continue;;
      @)  Push AFTER_SYNC "${J}"; continue;;
      \~) Push BEFORE_RSYNC "${J}"; continue;;
      !)  [[ "${NOLAYMAN}" ]] || DoExecute "${J}"; continue;;
    esac
    [[ "${NOLAYMAN}" ]] && continue
    RootTest
    if [[ "${J}" = "*" ]]; then
      MyRunCommand "Syncing all portage overlays"
        "${MYCMD}" -S || die "${MYCMD} -S failed"
      continue;
    fi
    MyRunCommand "Syncing portage overlay '${J}'"
      "${MYCMD}" -s "${J}" || die "${MYCMD} -s ${J} failed"
  done <"${LAYMANCONF}"
}


# Get options from cli
declare -a EMERGECMD

DefaultOpts () {
  EMERGECMD=("emerge" "--sync")
  CLEARCACHE='1'
  NOLAYMAN=''
  NOHOOKS=''
  VERBOSE=''
  QUIET=''
  USETEMP=''
  METADATA=''
  SKIP_SYNC=''
  SERVER=''
  CLIENT=''
  DOUPDATE='1'
  SYNCHOOKS='1'
  TEST_FOR_ROOT='1'
}

DefaultOpts
ExecuteConfig 'opts'

while getopts "ids:2:Uul@SmMtvqwWc:C:rRe?hH" OPTION \
  ${CONFIG_OPTS} ${EIX_SYNC_OPTS} "${@}"; do
  case "${OPTION}" in
    i) DefaultOpts;;
    d) DiffOnly;;
    s) SERVER="${OPTARG}";;
    2) CLIENT="${OPTARG}";;
    U) DOUPDATE='';;
    u) NOLAYMAN=1; NOHOOKS=1; SKIP_SYNC=1; SERVER='';;
    l) NOLAYMAN=1;;
    @) NOHOOKS=1;;
    S) SYNCHOOKS='';;
    m) SKIP_SYNC=1;;
    M) METADATA=1;;
    t) USETEMP=1;;
    v) VERBOSE=1;;
    q) QUIET=1;;
    w) EMERGECMD=("emerge-webrsync");;
    W) EMERGECMD=("emerge-delta-webrsync");;
    c) EMERGECMD=(); EMERGECMD[0]="${OPTARG}";;
    C) Push EMERGECMD "${OPTARG}";;
    r) CLEARCACHE=1;;
    R) CLEARCACHE='';;
    e) TEST_FOR_ROOT='';;
    *) Usage 1;;
  esac
done
[[ "${DOUPDATE}" ]] || CLEARCACHE=''
[[ "${SERVER}" ]] && SKIP_SYNC=1
[[ "${SKIP_SYNC}" ]] && METADATA=1

# We need a special function to treat the reserved word "time" like a command.
# (Of course "eval" would do a similar thing, but would also apply to args).
MyRun () {
  if [[ "${1}" != 'time' ]]; then
    "${@}"
    return
  fi
  shift
  time "${@}"
  return
}

# Run command
# if VERBOSE is empty, redirect 1,2 to logfile|/dev/null and use ebegin/eend
# (instead of einfo)
MyRunCommand () {
  local RET
  [[ "${EMULATEMODE}" ]] && return 0
  if [[ "${VERBOSE}" ]]; then
    einfo "${1}"
    shift
    MyRun "${@}"
    return "${?}"
  fi
  ebegin "${1}"
  shift
  MyRun "${@}" &>>"${REDIRECT}"
  RET="${?}"
  eend "${RET}" "Problems running ${@}"
  return "${RET}"
}

DoExecute () {
  [[ "${EMULATEMODE}" ]] && return 0
  (
    for CURRENT_COMMAND; do
      MyRunCommand "Executing ${CURRENT_COMMAND}" \
        eval "${CURRENT_COMMAND}" ||
          die "Something went wrong with ${CURRENT_COMMAND}"
    done
  ) || die
}

DoHook () {
  [[ "${NOHOOKS}" ]] && return 0
  DoExecute "${@}"
}

RootTest () {
  [[ "${EMULATEMODE}" ]] || return
  eerror ""
  eerror "Nothing was executed, because a heuristic shows that"
  eerror "root permissions are required to execute everything successfully."
  einfo  ""
  einfo  "However, the heuristic might be wrong, e.g. if you use EPREFIX."
  einfo  "If you want to skip this test temporarily, use option -e."
  einfo  "If you want to skip this test permanently, put option -e"
  einfo  "into the file ${LAYMANCONF}."
  die    ""
}

SED1='s!^[[:space:]]*'
SED2="[[:space:]]*=[[:space:]]*\([^[:space:]]*\)[[:space:]]*\$!\1!p"
SedFor () {
  local A=''
  [[ -e "${2}" ]] && \
    A="$(sed -n -e "${SED1}${1}${SED2}" -- "${2}" | tail -n 1)"
  A="${A%\"}"
  A="${A#\"}"
  A="${A%'}"
  A="${A#'}"
  echo "${A}"
}

TMPFILE=''
EXITCODE=0
DelTemp () {
  [[ "${TMPFILE}" ]] && rm -f -- "${TMPFILE}"
  trap '' 0 1 2 15
  exit ${EXITCODE}
}
MakeTempFile () {
  local COUNT
  if type mktemp &>/dev/null; then
    TMPFILE="$(mktemp /tmp/${0##*/}.XXXXXX)" ||
      die "cannot create temporary file"
  else
    COUNT=0
    while true; do
      ((COUNT++ == 10000)) && \
        die "found no free tempname after 10000 attempts"
      TMPFILE="/tmp/${0##*/}.$$.${RANDOM}.${RANDOM}.${RANDOM}"
      [[ -e "${TMPFILE}" ]] && continue
      >"${TMPFILE}" || die "cannot create temporary file ${TMPFILE}"
      break
    done
  fi
  trap DelTemp 0 1 2 15
}

PREPRSYNC=''
PrepRsync () {
  local CURRENT_COMMAND PORTAGE_RSYNC_OPTS PORTAGE_RSYNC_EXTRA_OPTS
  GetPortdir
  HOSTDIR="${1#*:}"
  if [[ "${HOSTDIR}" && "${HOSTDIR}" != "${1}" ]]; then
    HOSTDIR="${1}"
  else
    HOSTDIR="${1%%:*}:${LOCAL_PORTDIR}"
  fi
  HOSTDIR="${HOSTDIR%/}/"
  [[ "${PREPRSYNC}" ]] && return
  PORTAGE_RSYNC_OPTS="$(portageq envvar PORTAGE_RSYNC_OPTS)"
  PORTAGE_RSYNC_EXTRA_OPTS="$(portageq envvar PORTAGE_RSYNC_EXTRA_OPTS)"
  for CURRENT_COMMAND in "${BEFORE_RSYNC[@]}"; do
    eval "$(eval "${CURRENT_COMMAND}")" || die "${CURRENT_COMMAND} failed"
  done
  RSYNC_OPTS="${PORTAGE_RSYNC_OPTS} ${PORTAGE_RSYNC_EXTRA_OPTS}"
  PREPRSYNC=1
}

ClearCache () {
  [[ "${CLEARCACHE}" ]] || return
  # Cleaning old cache
  # portage 2.1_pre1 doesn't do this anymore, so *we* need to do it.
  RootTest
  MyRunCommand "Removing old portage-cache in ${LOCAL_VARCACHE}/var/cache/edb/dep" \
    rm -rf -- "${LOCAL_VARCACHE}"/var/cache/edb/dep/* || \
      die "rm -rf ${LOCAL_VARCACHE}/var/cache/edb/dep/* failed"
}

CallEmergeSync () {
  if [[ "${SERVER}" ]]; then
    [[ "${EMULATEMODE}" ]] && return
    PrepRsync "${SERVER}"
    MyRunCommand "rsyncing from ${HOSTDIR}" \
      rsync $RSYNC_OPTS "${HOSTDIR}" "${LOCAL_PORTDIR}" || \
        die "Could not rsync from ${HOSTDIR}"
    return
  fi
  [[ "${SKIP_SYNC}" ]] && return
  RootTest
  MyRunCommand "Running ${EMERGECMD[*]}" \
    time "${EMERGECMD[@]}" || die "${EMERGECMD[*]} failed"
}

CallSyncClient () {
  [[ "${EMULATEMODE}" ]] && return
  [[ "${CLIENT}" ]] || return
  PrepRsync "${CLIENT}"
  MyRunCommand "rsyncing to ${HOSTDIR}" \
    rsync ${RSYNC_OPTS} "${LOCAL_PORTDIR}" "${HOSTDIR}" || \
      die "Could not rsync to ${HOSTDIR}"
}

TESTRESULT=''
CallEmergeMetadata () {
  [[ "${DOUPDATE}" && "${METADATA}" ]] || return
  if [[ -z "${TESTRESULT}" ]]; then
    if [[ "$(SedFor 'portdbapi.auxdbmodule' "${PMOD}")" = "${MODULENAME}" ]]
    then
      TESTRESULT=0
    else
      TESTRESULT=1
    fi
  fi
  if [[ "${TESTRESULT}" -eq 0 ]]; then
    [[ "${EMULATEMODE}" ]] || \
      einfo "emerge --metadata is skipped due to settings in ${PMOD}"
    return
  fi
  RootTest
  MyRunCommand "Running emerge --metadata" \
    emerge --metadata || die "emerge --metadata failed"
}

CondUpdate () {
  if [[ ! -f "${EIXCACHE}" ]]; then
    RootTest
    MyRunCommand "eix-cache doesn't exist. Running update-eix!" \
        update-eix || die "update-eix failed"
    return
  fi
  [[ "${EMULATEMODE}" ]] && return
  if ! eix --is-current; then
    MyRunCommand "eix-cache uses obsolete format. Running update-eix!" \
        update-eix || die "update-eix failed"
  fi
}

CopyPrevious () {
  [[ "${DOUPDATE}" ]] || return
  [[ "${EMULATEMODE}" ]] && return
  MakeTempFile
  ( umask 002 ; cp -- "${EIXCACHE}" "${TMPFILE}" ) ||
    die "Could not copy database to temporary file ${TMPFILE}"
}

MovePrevious () {
  [[ "${USETEMP}" ]] && return
  ( umask 002
    MyRunCommand "Copying old ${EIXCACHE} cache to ${EIXPREVIOUS}" \
      mv -f -- "${TMPFILE}" "${EIXPREVIOUS}" ) ||
      die "Could not move ${TMPFILE} to ${EIXPREVIOUS}"
  [[ "${UID}" -eq 0 ]] && chown -- "portage:portage" "${EIXPREVIOUS}" &>/dev/null
  chmod -- 664 "${EIXPREVIOUS}" &>/dev/null
}

UpdateDiff () {
  local D
  [[ "${DOUPDATE}" ]] || return
  if [[ "${USETEMP}" ]]; then
    [[ "${EMULATEMODE}" ]] && return
    D="${TMPFILE}"
  else
    D="${EIXPREVIOUS}"
    [[ -e "${D}" ]] || RootTest
    [[ "${EMULATEMODE}" ]] && return
  fi
  if [[ "${EIXCACHE}" -nt "${TMPFILE}" ]]; then
    MovePrevious
    einfo "update-eix was apparently already called in a hook"
  else
    MovePrevious
    MyRunCommand "Running update-eix" "update-eix" || \
      die "Failure while running update-eix"
  fi
  DoHook "${AFTER_UPDATE[@]}"
  diff-eix -- "${D}" || die "Failed to diff against current cache"
}

MainSync () {
  CondUpdate
  ClearCache
  CopyPrevious
  ExecuteConfig 'sync'
  CallEmergeSync
  [[ "${SYNCHOOKS}" ]] && DoHook "${AFTER_SYNC[@]}"
  CallSyncClient
  CallEmergeMetadata
  UpdateDiff
}

if [[ "${UID}" -ne 0 ]] && [[ "${TEST_FOR_ROOT}" ]]; then
# Emulate everything to check whether we have to be root:
  EMULATEMODE=1
  MainSync
fi
EMULATEMODE=''

# Clean out logfile and redirect
if (
     umask 002
     if [[ "${QUIET}" || -z "${VERBOSE}" ]]; then
       >"${LOGFILE}" || exit 1
       [[ "${UID}" -eq 0 ]] && \
         chown -- "portage:portage" "${LOGFILE}" &>/dev/null
     fi
     exit 0
   ) &>/dev/null
then
  REDIRECT="${LOGFILE}"
else
  REDIRECT=/dev/null
  eerror "Redirection to ${LOGFILE} failed. Using ${REDIRECT} instead"
fi
[[ "${QUIET}" ]] && exec >>"${REDIRECT}"

MainSync

exit 0
