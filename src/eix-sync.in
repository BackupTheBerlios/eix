#!/bin/bash
# Authors: Emil Beinroth <emilbeinroth@gmx.net>
#          Martin Väth <vaeth@mathematik.uni-wuerzburg.de>

###########################################################################
#   eix is a small utility for searching ebuilds in the                   #
#   Gentoo Linux portage system. It uses indexing to allow quick searches #
#   in package descriptions with regular expressions.                     #
#                                                                         #
#   https://sourceforge.net/projects/eix                                  #
#                                                                         #
#   Copyright (c)                                                         #
#     Wolfgang Frisch <xororand@users.sourceforge.net>                    #
#     Emil Beinroth <emilbeinroth@gmx.net>                                #
#     Martin Väth <vaeth@mathematik.uni-wuerzburg.de>                     #
#                                                                         #
#   This program is free software; you can redistribute it and/or modify  #
#   it under the terms of the GNU General Public License as published by  #
#   the Free Software Foundation; either version 2 of the License, or     #
#   (at your option) any later version.                                   #
#                                                                         #
#   This program is distributed in the hope that it will be useful,       #
#   but WITHOUT ANY WARRANTY; without even the implied warranty of        #
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the         #
#   GNU General Public License for more details.                          #
#                                                                         #
#   You should have received a copy of the GNU General Public License     #
#   along with this program; if not, write to the                         #
#   Free Software Foundation, Inc.,                                       #
#   59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.             #
###########################################################################

source /sbin/functions.sh

EIXCACHE="@EIX_CACHEFILE@"
EIXPREVIOUS="${EIXCACHE%/*}/eix.previous"
GENSYNCCONF="/etc/eix-sync.conf"
LOGFILE="/var/log/eix-sync.log"
PMOD='/etc/portage/modules'
MODULENAME='cache.metadata_overlay.database'

# print message and die a horrible death
die () {
  eerror "${*}"; EXITCODE=2; exit "${EXITCODE}"
}

Usage () {
  echo "${0##*/} [options]
Call gensync/emerge --sync/--metadata and/or show updates. (@PACKAGE_STRING@)

Unless the -v option is used, the output of most commands is redirected to
    ${LOGFILE}.
Unless the -t option is used, the old database will be saved to
    ${EIXPREVIOUS}.

The file ${GENSYNCCONF} determines for which overlays gensync is called.
You can also add certain hooks in that file - \"man eix\" for details.

The following options are available:

-d   Only show differences to the previously saved database and exit.
     This is equivalent to diff-eix ${EIXPREVIOUS}.
-s [user@]SERVER Sync via rsync from SERVER. This option implies -m.
-2 [user@]CLIENT Sync via rsync *to* CLIENT after successfull syncing;
     you should later call eix-sync -u locally on CLIENT.
     If you already have synced you might want to combine this option with -uU.
-U   Do not touch the database and omit the hooks after update-eix (@ entries)
     and do not show differences. This option implies -R
-u   Update database only and show differences. This is equivalent to -g@m.
-g   Do not call gensync (and the !commands in ${GENSYNCCONF}).
     However, the postponed hooks (@ and @@ entries) will be executed anyway.
-@   Do not execute the hooks (@ and @@ entries) of ${GENSYNCCONF}.
-S   Do not execute the hooks after emerge --sync (@@ entries).
-m   Run emerge --metadata instead of emerge --sync.
     emerge --metadata is skipped if you use portage's metadata overlay module
     or if option -U is used.
-t   Use temporary file to save the current database (-d will not be possible).
-v   Don't suppress output of update-eix and emerge.
-q   Be quiet (close stdout).
-w   Run emerge-webrsync instead of emerge --sync.
-r   Really recreate the dep-cache (rm -rf /var/cache/edb/dep/*) (default).
-R   Do not really recreate the dep-cache."
  EXITCODE="${1}"
  exit ${1}
}

DiffOnly() {
  [[ -e "${EIXPREVIOUS}" ]] || die "No previous database ${EIXPREVIOUS} exists"
  exec diff-eix "${EIXPREVIOUS}"
  die "Could not execute diff-eix"
}

# Get options from cli
declare -a EMERGECMD
EMERGECMD=("emerge" "--sync")
CLEARCACHE=1
NOGENSYNC=''
NOHOOKS=''
VERBOSE=''
QUIET=''
USETEMP=''
METADATA=''
SERVER=''
CLIENT=''
DOUPDATE='1'
SYNCHOOKS='1'
while getopts "ds:2:Uug@SmtvqwrR?hH" OPTION; do
  case "${OPTION}" in
    d) DiffOnly;;
    s) SERVER="${OPTARG}";;
    2) CLIENT="${OPTARG}";;
    U) DOUPDATE='';;
    u) NOGENSYNC=1; NOHOOKS=1; METADATA=1;;
    g) NOGENSYNC=1;;
    @) NOHOOKS=1;;
    S) SYNCHOOKS='';;
    m) METADATA=1;;
    t) USETEMP=1;;
    v) VERBOSE=1;;
    q) QUIET=1;;
    w) EMERGECMD=("emerge-webrsync");;
    r) CLEARCACHE=1;;
    R) CLEARCACHE='';;
    *) Usage 1;;
  esac
done
[[ "${DOUPDATE}" ]] && CLEARCACHE=''
[[ "${SERVER}" ]] && METADATA=1

# Run command
# if VERBOSE is empty, redirect 1,2 to /dev/null and use ebegin/eend
# (instead of einfo)
RunCommand () {
  local RET
  [[ "${EMULATEMODE}" ]] && return 0
  if [[ "${VERBOSE}" ]]; then
    einfo "${1}"
    shift
    "${@}"
    return "${?}"
  fi
  ebegin "${1}"
  shift
  "${@}" &>"${REDIRECT}"
  RET="${?}"
  eend "${RET}" "Problems running ${@}"
  return "${RET}"
}

DoExecute () {
  [[ "${EMULATEMODE}" ]] && return 0
  (
    for CURRENT_COMMAND; do
      RunCommand "Executing ${CURRENT_COMMAND}" \
        eval "${CURRENT_COMMAND}" ||
          die "Something went wrong with ${CURRENT_COMMAND}"
    done
  ) || die
}

DoHook () {
  [[ "${NOHOOKS}" ]] && return 0
  DoExecute "${@}"
}

RootTest () {
  [[ "${UID}" -eq 0 ]] || die "You need to be root."
}

RootCommand () {
  RootTest
  RunCommand "${@}"
}

SED1='s!^[[:space:]]*'
SED2="[[:space:]]*=[[:space:]]*\([^[:space:]]*\)[[:space:]]*\$!\1!p"
SedFor () {
  local A=''
  [[ -e "${2}" ]] && \
    A="$(sed -n -e "${SED1}${1}${SED2}" "${2}" | tail -n 1)"
  A="${A%\"}"
  A="${A#\"}"
  A="${A%'}"
  A="${A#'}"
  echo "${A}"
}

TMPFILE=''
EXITCODE=0
DelTemp () {
  [[ "${TMPFILE}" ]] && rm -f "${TMPFILE}"
  trap '' 0 1 2 15
  exit ${EXITCODE}
}
MakeTempFile () {
  if type mktemp &>/dev/null; then
    TMPFILE="$(mktemp /tmp/${0##*/}.XXXXXX)" ||
      die "cannot create temporary file"
  else
    TMPFILE="/tmp/${0##*/}.$$"
    [[ -e "${TMPFILE}" ]] && \
      die "temporary name ${TMPFILE} already exists"
    mkdir "${TMPFILE}" || die "cannot create ${TMPFILE}"
  fi
  trap DelTemp 0 1 2 15
}

declare -a AFTER_SYNC AFTER_UPDATE BEFORE_RSYNC
AFTER_SYNC=()
AFTER_UPDATE=()
BEFORE_RSYNC=()
if [[ -r "${GENSYNCCONF}" ]]; then
  HAVECONF=1
else
  HAVECONF=''
fi
CallGensync () {
  local I J MYCMD
  [[ "${HAVECONF}" ]] || return
  while read I; do
    J="${I%%#*}"
    while [[ "${J% }" != "${J}" ]]; do J="${J%?}"; done
    while [[ "${J:0:1}" = " " ]]; do J="${J#?}"; done
    [[ "${J}" ]] || continue
    case "${J}" in
      !*)  J="${J#?}"; MYCMD='!';;
      @@*) J="${J#??}"; MYCMD='@@';;
      @*)  J="${J#?}"; MYCMD='@';;
      \~*)  J="${J#?}"; MYCMD='~';;
      *)   MYCMD="gensync";;
    esac
    [[ "${EMULATEMODE}" ]] && continue
    case "${MYCMD}" in
      @@) AFTER_UPDATE[${#AFTER_UPDATE[@]}]="${J}"; continue;;
      @)  AFTER_SYNC[${#AFTER_SYNC[@]}]="${J}"; continue;;
      \~)  BEFORE_RSYNC[${#BEFORE_RSYNC[@]}]="${J}"; continue;;
      !)  [[ "${NOGENSYNC}" ]] || DoExecute "${J}"; continue;;
    esac
    [[ "${NOGENSYNC}" ]] && continue
    if [[ "${J}" = "*" ]]; then
      RootCommand "Syncing all portage overlays"
        "${MYCMD}" -a || die "${MYCMD} -a failed"
      continue;
    fi
    RootCommand "Syncing portage overlay '${J}'"
      "${MYCMD}" "${J}" || die "${MYCMD} ${J} failed"
  done <"${GENSYNCCONF}"
}

PREPRSYNC=''
PrepRsync () {
  local CURRENT_COMMAND PORTAGE_RSYNC_OPTS PORTAGE_RSYNC_EXTRA_OPTS
  [[ "${PREPRSYNC}" ]] && return
  PORTDIR="$(portageq portdir)" || PORTDIR="/usr/portage"
  PORTDIR_CLIENT="${PORTDIR}"
  PORTDIR_SERVER="${PORTDIR}"
  PORTAGE_RSYNC_OPTS="$(portageq envvar PORTAGE_RSYNC_OPTS)"
  PORTAGE_RSYNC_EXTRA_OPTS="$(portageq envvar PORTAGE_RSYNC_EXTRA_OPTS)"
  for CURRENT_COMMAND in "${BEFORE_RSYNC[@]}"; do
    eval "$(eval "${CURRENT_COMMAND}")" || die "${CURRENT_COMMAND} failed"
  done
  RSYNC_OPTS="${PORTAGE_RSYNC_OPTS} ${PORTAGE_RSYNC_EXTRA_OPTS}"
  PREPRSYNC=1
}

ClearCache () {
  [[ "${CLEARCACHE}" ]] || return
  # Cleaning old cache
  # portage 2.1_pre1 doesn't do this anymore, so *we* need to do it.
  RootCommand "Removing old portage-cache in /var/cache/edb/dep/*" \
    rm -rf /var/cache/edb/dep/* || die "rm -rf /var/cache/edb/dep/* failed"
}

CallEmergeSync () {
  [[ "${EMULATEMODE}" ]] && return
  if [[ "${SERVER}" ]]; then
    PrepRsync
    RunCommand "rsyncing from ${SERVER}" \
      rsync $RSYNC_OPTS "${SERVER}:${PORTDIR_SERVER}/" "${PORTDIR}" || \
        die "Could not rsync from ${SERVER}:${PORTDIR_SERVER}"
  fi
  [[ "${METADATA}" ]] && return
  RootCommand "Running ${EMERGECMD[*]}" \
    "${EMERGECMD[@]}" || die "${EMERGECMD[*]} failed"
}

CallSyncClient () {
  [[ "${EMULATEMODE}" ]] && return
  [[ "${CLIENT}" ]] || return
  PrepRsync
  RunCommand "rsyncing to ${CLIENT}" \
    rsync $RSYNC_OPTS "${PORTDIR}" "${CLIENT}:${PORTDIR_CLIENT}/" || \
      die "Could not rsync to ${CLIENT}:${PORTDIR_CLIENT}"
}

TESTRESULT=''
CallEmergeMetadata () {
  [[ "${DOUPDATE}" && "${METADATA}" ]] || return
  if [[ -z "${TESTRESULT}" ]]; then
    if [[ "$(SedFor 'portdbapi.auxdbmodule' "${PMOD}")" = "${MODULENAME}" ]]
    then
      TESTRESULT=0
    else
      TESTRESULT=1
    fi
  fi
  if [[ "${TESTRESULT}" -eq 0 ]]; then
    [[ "${EMULATEMODE}" ]] || \
      einfo "emerge --metadata is skipped due to settings in ${PMOD}"
    return
  fi
  RootCommand "Running emerge --metadata" \
    emerge --metadata || die "emerge --metadata failed"
}

CondUpdate () {
  if [[ ! -f "/var/cache/eix" ]]; then
    RootCommand "eix-cache doesn't exist. Running update-eix!" \
        update-eix || die "update-eix failed"
    return
  fi
  [[ "${EMULATEMODE}" ]] && return
  if ! eix --is-current; then
    RunCommand "eix-cache uses obsolete format. Running update-eix!" \
        update-eix || die "update-eix failed"
  fi
}

CopyDiff () {
  local D
  [[ "${DOUPDATE}" ]] || return
  if [[ "${USETEMP}" ]]; then
    [[ "${EMULATEMODE}" ]] && return
    MakeTempFile
    D="${TMPFILE}"
  else
    D="${EIXPREVIOUS}"
    [[ -e "${D}" ]] || RootTest
    [[ "${EMULATEMODE}" ]] && return
  fi
  ( umask 002 ; cp "${EIXCACHE}" "${D}" ) ||
    die "Could not copy database to ${D}"
  RunCommand "Running update-eix" "update-eix" || \
    die "Failure while running update-eix"
  DoHook "${AFTER_UPDATE[@]}"
  diff-eix "${D}" || die "Failed to diff against current cache"
}

MainSync () {
  CondUpdate
  ClearCache
  CallGensync
  CallEmergeSync
  [[ "${SYNCHOOKS}" ]] && DoHook "${AFTER_SYNC[@]}"
  CallSyncClient
  CallEmergeMetadata
  CopyDiff
}

if [[ "${UID}" -ne 0 ]]; then
# Emulate everything to check whether we have to be root:
  EMULATEMODE=1
  MainSync
fi
EMULATEMODE=''

# Clean out logfile and redirect
if (
     umask 002
     if [[ "${QUIET}" || -z "${VERBOSE}" ]]; then
       >"${LOGFILE}"
       [[ "${UID}" -eq 0 ]] && chown portage:portage "${LOGFILE}"
     fi
   ) &>/dev/null
then
  REDIRECT="${LOGFILE}"
else
  REDIRECT=/dev/null
  eerror "Redirection to ${LOGFILE} failed. Using ${REDIRECT} instead"
fi
[[ "${QUIET}" ]] && exec >>"${REDIRECT}"

MainSync

exit 0
