#! /usr/bin/env sh
# This script is part of the eix project and distributed under the
# terms of the GNU General Public License v2.
#
# Authors and Copyright (c):
#   Emil Beinroth <emilbeinroth@gmx.net> (original)
#   Martin V\"ath <vaeth@mathematik.uni-wuerzburg.de> (complete rewrite)
#
# This script calls emerge --sync and shows the differences.
# See the eix manpage for details. (@PACKAGE_STRING@).

. ./update-eix-functions.sh.in

LOCAL_VARCACHE="`update-eix --print EPREFIX_PORTAGE_CACHE`"
EIXCACHE="`update-eix --print EIX_CACHEFILE`"
EIXPREVIOUS="${EIXCACHE}.previous"
LOCAL_PORTAGE_CONFIGROOT="`update-eix --print PORTAGE_CONFIGROOT`"
LAYMANCONF="${LOCAL_PORTAGE_CONFIGROOT}/etc/eix-sync.conf"
LOGFILE="${LOCAL_EPREFIX_PORTAGE_EXEC}/var/log/eix-sync.log"
PMOD="${LOCAL_PORTAGE_CONFIGROOT}/etc/portage/modules"
MODULENAME='cache.metadata_overlay.database'

Usage() {
	echo "${0##*/} [options]
Call layman/emerge --sync/--metadata and/or show updates. (@PACKAGE_STRING@)

Unless the -v option is used, the output of most commands is redirected to
    ${LOGFILE}.
Unless the -t option is used, the old database will be saved to
    ${EIXPREVIOUS}.

The file ${LAYMANCONF} determines for which overlays layman is called.
You can also add certain hooks in that file - \"man eix\" for details.

The file ${LAYMANCONF} and the environment variable EIX_SYNC_OPTS can
contain default options which are processed before the command line options.
Note that \"--\" in the default options will forbid command line options.
The following options are available:

-i   Ignore all previous options (useful to ignore the default options).
-d   Only show differences to the previously saved database and exit.
     This is equivalent to diff-eix ${EIXPREVIOUS}.
-s [USER@]SERVER[:DIR] Sync via rsync from SERVER. This option implies -m.
     USER defaults to current user and DIR defaults to \$PORTDIR
-2 [USER@]CLIENT[:DIR] Sync via rsync *to* CLIENT after successfull syncing;
     you should later call eix-sync -u locally on CLIENT.
     If you already have synced you might want to combine this option with -uU.
-U   Do not touch the database and omit the hooks after update-eix (@ entries)
     and do not show differences. This option implies -R
-u   Update database only and show differences. This is equivalent to -l@ms ''
-l   Do not call layman (and the !commands in ${LAYMANCONF}).
     However, the postponed hooks (@ and @@ entries) will be executed anyway.
-@   Do not execute the hooks (@ and @@ entries) of ${LAYMANCONF}.
-S   Do not execute the hooks after emerge --sync (@@ entries).
-m   Run emerge --metadata but not emerge --sync.
     emerge --metadata is skipped if you use portage's metadata overlay module
     or if option -U is used.
-M   Run emerge --metadata in addition to emerge --sync.
     This is probably only useful in conjunction with -c.
-t   Use temporary file to save the current database (-d will not be possible).
-v   Do not redirect output of update-eix and emerge into logfile.
-V   Cancel previous -v (useful if you used -v in /etc/eix-sync.conf)
-q   Be quiet (close stdout, redirecting into logfile)
-w   Run emerge-webrsync instead of emerge --sync.
-W   Run emerge-delta-webrsync instead of emerge --sync.
-c CMD Run CMD instead of emerge --sync.
-C OPT Add OPT to the emerge --sync command (or whatever is used instead).
-r   Really recreate the dep-cache (rm -rf ${LOCAL_VARCACHE}/var/cache/edb/dep/*) (default).
-R   Do not really recreate the dep-cache.
-e   Skip heuristic tests whether you must be root.
-h   Show this text and exit."
	EXITCODE=${1:-1}
	exit ${1}
}

DiffOnly() {
	test -e "${EIXPREVIOUS}" || die "No previous database ${EIXPREVIOUS} exists"
	exec diff-eix -- "${EIXPREVIOUS}"
	die "Could not execute diff-eix"
}

if test -r "${LAYMANCONF}"; then
	HAVECONF=true
else
	HAVECONF=false
fi
ExecuteConfig() {
	local I J MYCMD
	AFTER_SYNC=''
	AFTER_UPDATE=''
	BEFORE_RSYNC=''
	CONFIG_OPTS=''
	${HAVECONF} || return 0
	while read I; do
		J="${I%%#*}"
		while [ "${J% }" != "${J}" ]; do J="${J%?}"; done
		while [ "${J# }" != "${J}" ]; do J="${J#?}"; done
		[ -n "${J}" ] || continue
		case "${J}" in
			!*)  J="${J#?}"; MYCMD='!';;
			@@*) J="${J#??}"; MYCMD='@@';;
			@*)  J="${J#?}"; MYCMD='@';;
			\~*) J="${J#?}"; MYCMD='~';;
			-*)  CONFIG_OPTS="${CONFIG_OPTS} ${J}"; continue;;
			'export '*) [ "${1}" = 'opts' ] && eval "${J}"
				continue;;
			*)   MYCMD="layman";;
		esac
		[ "${1}" = 'opts' ] && continue
		case "${MYCMD}" in
			'@@')	Push AFTER_UPDATE "${J}"; continue;;
			'@')	Push AFTER_SYNC "${J}"; continue;;
			'~')	Push BEFORE_RSYNC "${J}"; continue;;
			'!')	${NOLAYMAN} || DoExecute "${J}"; continue;;
		esac
		${NOLAYMAN} && continue
		RootTest
		if [ "${J}" = '*' ]; then
			MyRunCommand "Syncing all portage overlays"
				"${MYCMD}" -S || die "${MYCMD} -S failed"
			continue;
		fi
		MyRunCommand "Syncing portage overlay '${J}'"
			"${MYCMD}" -s "${J}" || die "${MYCMD} -s ${J} failed"
	done <"${LAYMANCONF}"
}


# Get options from cli

DefaultOpts() {
	Push -c EMERGECMD 'emerge' '--sync'
	CLEARCACHE=true
	NOLAYMAN=false
	NOHOOKS=false
	VERBOSE=false
	QUIET=false
	USETEMP=false
	METADATA=false
	SKIP_SYNC=false
	SERVER=''
	CLIENT=''
	DOUPDATE=true
	SYNCHOOKS=true
	TEST_FOR_ROOT=true
}

DefaultOpts
ExecuteConfig 'opts'

while getopts "ids:2:Uul@SmMtvVqwWc:C:rRe?hH" OPTION \
	${CONFIG_OPTS} ${EIX_SYNC_OPTS} "${@}"; do
	case "${OPTION}" in
		i) DefaultOpts;;
		d) DiffOnly;;
		s) SERVER="${OPTARG}";;
		2) CLIENT="${OPTARG}";;
		U) DOUPDATE=false;;
		u) NOLAYMAN=true; NOHOOKS=true; SKIP_SYNC=true; SERVER='';;
		l) NOLAYMAN=true;;
		@) NOHOOKS=true;;
		S) SYNCHOOKS=false;;
		m) SKIP_SYNC=true;;
		M) METADATA=true;;
		t) USETEMP=true;;
		v) VERBOSE=true;;
		V) VERBOSE=false;;
		q) QUIET=true;;
		w) Push -c EMERGECMD 'emerge-webrsync';;
		W) Push -c EMERGECMD 'emerge-delta-webrsync';;
		c) Push -c EMERGECMD "${OPTARG}";;
		C) Push EMERGECMD "${OPTARG}";;
		r) CLEARCACHE=true;;
		R) CLEARCACHE=false;;
		e) TEST_FOR_ROOT=false;;
		*) Usage 0;;
	esac
done
${DOUPDATE} || CLEARCACHE=false
[ -z "${SERVER}" ] || SKIP_SYNC=true
${SKIP_SYNC} && METADATA=true

MyRun() {
	if [ "${1}" != 'time' ]; then
		"${@}"
		return
	fi
	shift
	if command -v time >/dev/null 2>&1; then
		time "${@}"
		return
	fi
	"${@}"
}

# Run command
# if VERBOSE is true, redirect 1,2 to logfile|/dev/null and use ebegin/eend
# (instead of einfo)
MyRunCommand() {
	local RET
	${EMULATEMODE} && return 0
	if ${VERBOSE}; then
		einfo "${1}"
		shift
		MyRun "${@}"
		return "${?}"
	fi
	ebegin "${1}"
	shift
	MyRun "${@}" >>"${REDIRECT}" 2>&1
	RET=${?}
	eend "${RET}" "Problems running ${@}"
	return ${RET}
}

DoExecute() {
	${EMULATEMODE} && return 0
	(
		for CURRENT_COMMAND; do
			MyRunCommand "Executing ${CURRENT_COMMAND}" \
			eval "${CURRENT_COMMAND}" || \
			die "Something went wrong with ${CURRENT_COMMAND}"
		done
	) || die
}

DoHook() {
	${NOHOOKS} && return 0
	eval "set -- ${1}"
	DoExecute "${@}"
}

RootTest() {
	${EMULATEMODE} || return 0
	eerror ""
	eerror "Nothing was executed, because a heuristic shows that"
	eerror "root permissions are required to execute everything successfully."
	einfo  ""
	einfo  "However, the heuristic might be wrong, e.g. if you use EPREFIX."
	einfo  "If you want to skip this test temporarily, use option -e."
	einfo  "If you want to skip this test permanently, put option -e"
	einfo  "into the file ${LAYMANCONF}."
	die    ""
}

SED1='s!^[[:space:]]*'
SED2="[[:space:]]*=[[:space:]]*\([^[:space:]]*\)[[:space:]]*\$!\1!p"
SedFor() {
	local A=''
	test -e "${2}" && \
		A=`sed -n -e "${SED1}${1}${SED2}" -- "${2}" | tail -n 1`
	A="${A%\"}"
	A="${A#\"}"
	A="${A%'}"
	A="${A#'}"
	echo "${A}"
}

TMPFILE=''
EXITCODE=0
DelTemp() {
	[ -z "${TMPFILE}" ] || rm -f -- "${TMPFILE}"
	TMPFILE=''
	trap - EXIT HUP INT TERM
	exit ${EXITCODE}
}
MakeTempFile() {
	local COUNT
	if command -v mktemp >/dev/null 2>&1; then
		TMPFILE=`mktemp "/tmp/${0##*/}.XXXXXX"` || \
			die "cannot create temporary file"
	else
		COUNT=0
		while true; do
			[ ${COUNT} -eq 9999 ] && \
				die "found no free tempname after 10000 attempts"
			COUNT="`expr ${COUNT} + 1`"
			TMPFILE="/tmp/${0##*/}.$$.${RANDOM}.${RANDOM}.${RANDOM}"
			test -e "${TMPFILE}" && continue
			: >"${TMPFILE}" || die "cannot create temporary file ${TMPFILE}"
			break
		done
	fi
	trap DelTemp EXIT HUP INT TERM
}

PREPRSYNC=false
PrepRsync() {
	GetPortdir
	HOSTDIR="${1#*:}"
	if [ -n "${HOSTDIR}" ] && [ "${HOSTDIR}" != "${1}" ]; then
		HOSTDIR="${1}"
	else
		HOSTDIR="${1%%:*}:${LOCAL_PORTDIR}"
	fi
	HOSTDIR="${HOSTDIR%/}/"
	${PREPRSYNC} && return
	local CURRENT_COMMAND PORTAGE_RSYNC_OPTS PORTAGE_RSYNC_EXTRA_OPTS C
	PORTAGE_RSYNC_OPTS="`portageq envvar PORTAGE_RSYNC_OPTS`"
	PORTAGE_RSYNC_EXTRA_OPTS="`portageq envvar PORTAGE_RSYNC_EXTRA_OPTS`"
	eval "set -- ${BEFORE_RSYNC}"
	for CURRENT_COMMAND; do
		C=`eval "${CURRENT_COMMAND}"` || \
			die "${CURRENT_COMMAND} failed"
		eval "${C}"
	done
	RSYNC_OPTS="${PORTAGE_RSYNC_OPTS} ${PORTAGE_RSYNC_EXTRA_OPTS}"
	PREPRSYNC=true
}

ClearCache() {
	${CLEARCACHE} || return 0
	# Cleaning old cache
	# portage 2.1_pre1 doesn't do this anymore, so *we* need to do it.
	RootTest
	MyRunCommand "Removing old portage-cache in ${LOCAL_VARCACHE}/var/cache/edb/dep" \
		rm -rf -- "${LOCAL_VARCACHE}"/var/cache/edb/dep/* || \
			die "rm -rf ${LOCAL_VARCACHE}/var/cache/edb/dep/* failed"
}

CallEmergeSync() {
	if [ -n "${SERVER}" ]; then
		${EMULATEMODE} && return
		PrepRsync "${SERVER}"
		MyRunCommand "rsyncing from ${HOSTDIR}" \
			rsync $RSYNC_OPTS "${HOSTDIR}" "${LOCAL_PORTDIR}" || \
				die "Could not rsync from ${HOSTDIR}"
		return
	fi
	${SKIP_SYNC} && return
	RootTest
	eval "set -- ${EMERGECMD}"
	MyRunCommand "Running ${*}" time "${@}" || die "${*} failed"
}

CallSyncClient() {
	${EMULATEMODE} && return
	[ -z "${CLIENT}" ] && return
	PrepRsync "${CLIENT}"
	MyRunCommand "rsyncing to ${HOSTDIR}" \
		rsync ${RSYNC_OPTS} "${LOCAL_PORTDIR}" "${HOSTDIR}" || \
			die "Could not rsync to ${HOSTDIR}"
}

TESTRESULT=''
CallEmergeMetadata() {
	${DOUPDATE} && ${METADATA} || return 0
	if [ -z "${TESTRESULT}" ]; then
		local S=`SedFor 'portdbapi.auxdbmodule' "${PMOD}"`
		if [ "${S}" = "${MODULENAME}" ]
		then
			TESTRESULT='false'
		else
			TESTRESULT='true'
		fi
	fi
	if [ "${TESTRESULT}" = 'false' ]; then
		${EMULATEMODE} || \
			einfo "emerge --metadata is skipped due to settings in ${PMOD}"
		return
	fi
	RootTest
	MyRunCommand "Running emerge --metadata" \
		emerge --metadata || die "emerge --metadata failed"
}

CondUpdate() {
	if ! test -f "${EIXCACHE}"; then
		RootTest
		MyRunCommand "eix-cache doesn't exist. Running update-eix!" \
				update-eix || die "update-eix failed"
		return
	fi
	${EMULATEMODE} && return
	if ! eix --is-current; then
		MyRunCommand "eix-cache format has changed. Running update-eix!" \
				update-eix || die "update-eix failed"
	fi
}

CopyPrevious() {
	${DOUPDATE} || return 0
	${EMULATEMODE} && return
	MakeTempFile
	( umask 002 ; cp -- "${EIXCACHE}" "${TMPFILE}" ) ||
		die "Could not copy database to temporary file ${TMPFILE}"
}

MovePrevious() {
	${USETEMP} && return
	(
		umask 002
		MyRunCommand "Copying old ${EIXCACHE} cache to ${EIXPREVIOUS}" \
		mv -f -- "${TMPFILE}" "${EIXPREVIOUS}"
	) || die "Could not move ${TMPFILE} to ${EIXPREVIOUS}"
	[ "${UID}" -eq 0 ] && \
		chown -- portage:portage "${EIXPREVIOUS}" >/dev/null 2>&1
	chmod -- 664 "${EIXPREVIOUS}" >/dev/null 2>&1
}

UpdateDiff() {
	local D
	${DOUPDATE} || return 0
	if ${USETEMP}; then
		${EMULATEMODE} && return
		D="${TMPFILE}"
	else
		D="${EIXPREVIOUS}"
		test -e "${D}" || RootTest
		${EMULATEMODE} && return
	fi
	if test "${EIXCACHE}" -nt "${TMPFILE}"; then
		MovePrevious
		einfo "update-eix was apparently already called in a hook"
	else
		MovePrevious
		MyRunCommand "Running update-eix" "update-eix" || \
			die "Failure while running update-eix"
	fi
	DoHook "${AFTER_UPDATE}"
	diff-eix -- "${D}" || die "Failed to diff against current cache"
}

MainSync() {
	CondUpdate
	ClearCache
	CopyPrevious
	ExecuteConfig 'sync'
	CallEmergeSync
	${SYNCHOOKS} && DoHook "${AFTER_SYNC}"
	CallSyncClient
	CallEmergeMetadata
	UpdateDiff
}

[ -n "${UID}" ] || UID="`id -u`"
if ${TEST_FOR_ROOT} && [ "${UID}" -ne 0 ]; then
# Emulate everything to check whether we have to be root:
	EMULATEMODE=true
	MainSync
fi
EMULATEMODE=false

# Clean out logfile and redirect
if (
	umask 002
	if ${QUIET} || ! ${VERBOSE}; then
		: >"${LOGFILE}" || exit 1
		[ "${UID}" -eq 0 ] && \
		chown -- portage:portage "${LOGFILE}" >/dev/null 2>&1
	fi
	exit 0
	) >/dev/null 2>&1
then
	REDIRECT="${LOGFILE}"
else
	REDIRECT=/dev/null
	eerror "Redirection to ${LOGFILE} failed. Using ${REDIRECT} instead"
fi
${QUIET} && exec >>"${REDIRECT}"

MainSync

exit 0
