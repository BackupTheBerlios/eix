.TH "eix" "1" "$Date: 2012-04-17 09:00:00 +0200 (Thu, 17 May 2012)$" "@PACKAGE_STRING@" ""
.\" {{{ NAME
.SH "NAME"
.B eix
- Programme zum Durchsuchen, Vergleichen und Updaten eines Binärcaches der lokalen Portage-Baums
.\" }}}

.\" {{{ Übersicht
.SH "ÜBERSICHT"
.B eix
[I<gemeinsame Optionen>] [I<OPTIONEN>] I<AUSDRUCK>

.B eix-update
[I<gemeinsame Optionen>] [I<eix-update-OPTIONEN>]

.B eix-diff
[I<gemeinsame Optionen>] [I<ALTER-CACHE>] [I<NEUER-CACHE>]

.B eix-sync

.B eix-test-obsolete

.B eix-remote

.B eix-layman

.B eix-installed-after

.B eix-installed

.B eix-functions.sh

.B eix-drop-permissions
[B<-->] [I<Befehl zum Ausführen>]

.B versionsort
.\" }}}

.\" {{{ BESCHREIBUNG
.SH "BESCHREIBUG"
B<eix-update> generiert einen Binärcache des lokalen Portage-Baums und von Overlays.
B<eix> durchsucht diesen Cache nach Paketen, die Kriterien erfüllen, die durch I<AUSDRUCK> festgelegt werden;
falls auf der Kommandozeile kein einschränkendes Kriterium angegeben wird, werden natürlich alle Pakete ausgegeben.
B<eix-diff> vergleicht zwei solcher Binärcache und gibt Pakete aus, die hinzugefügt oder entfernt wurden, oder für
die sich die höchste stabile Versionsnummer geändert hat.

Alle zugehörigen Programme und Skripte lesen die später beschrieben Konfigurationsfiles.
B<eix-sync> hat optional eine separate Konfigurations-Datei.

B<eix-sync> kann den Portage/Overlay-Baum syncen und vergleicht ihn mit dem alten Cache (vermöge B<eix-diff>).
Mehr über B<eix-sync> erfahren Sie durch den Aufruf B<eix-sync -h> und in der untenstehenden
Beschreibung von I<@SYSCONFDIR@/eix-sync.conf>.
Beachten Sie, dass der Inhalt dieser Datei auch in der Variablen B<EIX_SYNC_CONF> gespeichert werden kann.

B<eix-test-obsolete> ist ein Skript, das B<eix> mehrmals aufruft, um die Ausgabe von B<eix -tTc> besser organisiert auszugeben.

B<eix-remote> kann eine Eix-Datenbank von einem externen Server syncen und ihn zum
lokalen Cache hinzufügen und wieder entfernen.
Um solche Remote-Daten über B<eix-update>-Aufrufe zu erhalten, können Sie
B<KEEP_VIRTUALS=true> in @SYSCONFDIR@/eixrc setzen.
Per Default wird dieses Skript seine Rechte durch B<eix-drop-permissions> fallenlassen.
Mehr zu B<eix-remote> erfahren Sie durch den Aufruf B<eix-remote -h>.

B<eix-installed-after> ist ein einfaches Skript (mit vielen Kommentaren),
das einige Möglichkeiten aufzeigt, wie eine vom Skript angepasste eix-Ausgabe genutzt werden kann:
Das Skript gibt diejenigen Pakete aus, die nach (oder vor) dem letzten (oder ersten) Emerge eines
spezifizierten Pakets/Version installiert wurden.
Mehr zur Benutzung erfahren Sie durch den Aufruf B<eix-installed-after -h>.

B<eix-layman> kann lokale Layman-Overlays zur aktuellen Datenbank hinzufügen.
Dies kann hilfreich sein, wenn in der lokalen I</etc/make.conf> die von Layman erzeugte make.conf nicht gesourced wird.
Mehr zu B<eix-lamyan> erfahren Sie durch den Aufruf B<eix-layman -h>.
B<eix-layman> versteht sich auch als Beispielskript, wie B<eix-functions.sh>
genutzt werden kann:

B<eix-functions.sh> sind Hilfsfunktionen, die von B<eix-sync>, B<eix-remote>, und B<eix-layman>
benutzt werden und die in ähnlichen Skripten benutzt werden können.
Beachten Sie, dass unmittelbar nach dem Sourcen von B<eix-functions.sh> normalerweise
zur Initialisierung B<ReadFunctions> aufgerufen werden muss.

B<eix-drop-permissions> ist ein Hilfsprogramm für B<eix-remote> (und möglicherweise eigene Skripte).
Es führt das im Argument angegebene Kommando mit eingeschränkten Rechten aus.
Die Einschränkung wird durch B<EIX_USER>, B<EIX_GROUP>, B<EIX_UID>, B<EIX_GID> (siehe später) spezifiziert.
Beachten Sie, dass auch die Binärprogramme B<eix>, B<eix-diff> und B<eix-update> ihre
Rechte so früh wie möglich gemäß diesen Variablen einschränken, d.h. es kann nötig sein,
diese Variablen anzupassen, falls B<eix> (insbesondere B<eix-update>)
in einem Nichtstandard-Setting genutzt werden soll.

B<eix-installed> ist ein einfaches Skript, das alle installierten Pakete (und ihre exakte Version)
ausgibt, und das prüfen kann, welche Pakete mit/ohne Repository- oder Buildtime-Information gebaut wurden
(vgl. die Beschreibung zu B<CHECK_INSTALLED_OVERLAYS> und B<USE_BUILD_TIME>).
Mehr zu B<eix-installed> erfahren Sie durch den Aufruf B<eix-installed -h>.

B<versionsort> ist ein Hilfsprogramm für Skripte, das die Versionsnummer von
den Argumenten abtrennt, und das die gefundenen Versionsnummern gemäß den
Portage-Regeln sortiert.
Details stehen nahe beim Ende dieser Manpage.
.\" }}}

.\" {{{ BEISPIELE
.SH "BEISPIELE"

Die folgenden Beispiele sind nützliche aber vielleicht untypische Anwendungen von eix.
Sie werden hier aufgelistet, um eine Idee davon zu geben, welche unerwarteten Dinge mit eix mit möglich sind.
Da diese Beispiele mit cut-and-paste von dieser Seite kopiert werden sollten, sind sie gleich
zu Anfang aufgelistet.
Um zu verstehen, wie sie funktionieren, ist es natürlich notwendig, die vollständige  Manpage zu lesen.
Weitere Beispiele finden Sie beispielsweise im Skript B<eix-installed-after>, das viele Kommentare enthält.

.TP
.IB cmd " | eix '-|*' --format '<markedversions:NAMESLOT>'"

Falls I<cmd> eine Liste der Gestalt B<Kategorie/Name-Version> or B<=Kategorie/Name-Version>
 ausgibt, gibt das obige Kommando die entsprechende List B<Kategorie/Name> oder B<Kategorie/Name:SLOT> aus
(je nachdem, ob die B<SLOT>s unterschieden werden müssen).

.TP
.IB cmd " | eix '-|*' --format '<markedversions:NAMEASLOT>'"

Ähnlich wie eben, aber es wird immer B<Kategorie/Name:SLOT> ausgeben,
selbst wenn B<SLOT> redundant ist. (Mnemonic: B<A>lways).

.TP
.B eix '-I*' --format '<installedversions:NAMEVERSION>'

Gibt die installierten Pakete im Format B<Kategorie/Name-Version> aus.
Natürlich kann man B<NAMEVERSION> auch durch B<NAMESLOT> oder B<NAMEASLOT> ersetzen,
um ein anderes Format zu erhalten.
Der einzige Zweck der Option B<I> in diesem Zusammenhang ist eine geringfügige Beschleunigung der Ausgabe.

.TP
.B eix '-I*' --format '<installedversions:EQNAMEVERSION>'

Ähnlich wie eben, aber im Format B<=Kategorie/Name-Version>,
das direkt von Portage benutzt werden kann.

.TP
.B eix '-I*' --format '<installedversions:DATESORT>' | sort -n | cut -f2-3

Gibt die installierten Pakete (falls notwendig mit Slots) aus, sortiert nach Installationsdatum.
Zur Ausgabe in einem anderen Format kann B<DATESORT> entsprechend modifiziert werden
(die ursprüngliche Definition steht in der Ausgabe von B<eix --dump>).

Das Sortieren funktioniert folgendermaßen: Die B<DATESORT>-Variable gibt als
erste Spalte die Sekunden seit Epoch aus (Mit B<eix --print DATESORT> erfahren Sie,
dass dies durch die Variable B<DATESORT_DATE> geschieht, deren erster Eintrag B<%s> lautet),
und B<sort> erzeugt so durch einfaches alphabetisches Sortieren die korrekte Ordnung.
Das B<cut>-Kommando verschluckt schließlich wieder die erste Spalte, die nur zum Sortieren benötigt wurde.

In diesem Beispiel sind Dinge wie B<NAMEVERSION> oder B<DATESORT> nur Variablennamen,
die in eix vordefiniert wurden (B<eix --dump> listet sie auf).
Genausogut können natürlich auch eigene Variablen definiert und benutzt werden.
Genaueres dazu steht später in der Manpage, insbesonder die Beschreibung des B<FORMAT> Strings.
.\" }}}


.\" {{{ OPTIONEN
.SH "OPTIONEN"
.\" {{{ -------- gemeinsame Optionen
.SS gemeinsame Optionen
Die folgenden Optionen sind B<eix>, B<eix-diff> und B<eix-update> gemein:
.TP
.BR -h ", " --help
Ausgabe eines Hilfstextes und Ende.
.TP
.BR -Q ", " --quick "   (toggle)    (nicht für B<eix-update>)"
Verhindert/Ermöglicht, dass Slots installierter Versionen gelesen werden,
die nicht vermutet werden können (d.h. installierter Versionen von Paketen
mit mindestens zwei verschiedene Slots, für die die installierte Version
nicht mehr in der Datenbank ist).
Beachten Sie, dass mit dieser Option eix und eix-diff falsche Posittreffer
über Up-/Downgrade-Empfehlungen für diese Pakete ausgeben könnten.
.TP
.BR --care "    (nicht für B<eix-update>)"
Deaktiviert --quick, und darüberhinaus werden Slots installiertet Versionen
immer gelesen, auch dann wenn der Slotname vermutet werden kann.
Dies stellt insbesondere sicher, dass Up-/Downgrade-Empfehungen auch dann
ausgegben werden, wenn sich der Slotname einer installierten Version ändert.
Beachten Sie, dass diese Option die Geschwindigkeit beim ersten Aufruf
dramatisch reduziert. (Wenn das Dateisystem einen vernünftigen Cache hat,
werden spätere Aufrufe kaum langsamer sein als ohne diese Option).
.TP
.BR -q ", " --quiet "   (toggle)"
Ausgaben auf stdout werden verhindert.
Für eix kann ggf. die Ausführungszeit weiter reduziert werden, wenn diese
Kombination mit (je nach Einsatzzweck) entweder B<--brief> oder B<--brief2>
kombiniert wird, und durch Setzen von B<COUNT_ONLY_PRINTED=false>.
Siehe auch B<NOFOUND_STATUS> und B<MOREFOUND_STATUS>
.TP
.B --dump
Ausgabe der aktuellen eixrc-Variablen und ihre Defaults als Kommentar; dann Ende.
.TP
.B --dump-defaults
Ausgabe der Default-eixrc-Variablen und ihrer aktuellen Werte als Kommentar; dann Ende.
.TP
.BI "--print " VAR
Ausgabe der spezifizierten Variablen I<VAR> aus eixrc oder der Portage-Konfiguration; dann Ende.
Die Ausgabe erfolgt vollständig expandiert, so wie sie intern von eix benutzt würde.
Der Exit-Status ist positiv, falls I<VAR> eix unbekannt ist (siehe B<--known-vars>).
Diese Option ist hauptsächlich für Skripte nützlich oder zum Debuggen.
Zur Benutzung in Skripts empfiehlt sich die Benutzung von B<PRINT_APPEND>.
um das Abschneiden von Leerzeichen am Ende zu verhinden (siehe die Beschreibung zu B<PRINT_APPEND>).
.TP
.B --know-vars
Ausgabe eine alphabetischen Liste aller Variablen, die eix für B<--print> bekannt sind.
Nach jedem Variablennamen wird ein Zeilenumbruch ausgegeben.
.TP
.BR -V ", " --version
Ausgabe der Versionsnummer und Ende.
.TP
.BR -n ", " --nocolor
Verhindert die Ausgabe von ANSI Farbcodes;
nützlich für Terminals, die diese nicht kennen.
(Dies wird automatisch aktiv, falls stdout nicht auf ein tty führt, kann aber mit --force-color überschrieben werden).
.TP
.BR -F ", " --force-color
Das Gegenteil von --nocolor.
.\" }}}

.\" {{{ -------- eix ausschließend
.SS Spezielle Informations-Optionen
Die folgenden speziellen Informations-Optionen versteht nur das eigentliche B<eix>-Programm.
Sie sind einmalig und ausschließend, d.h. eix gibt nur die entsprechenden Daten aus und beendet sich dann.
.TP
.BI "--print-overlay-path " OVERLAY
Gibt den Pfad des ersten Overlays aus, der auf I<OVERLAY> zutrifft.
I<OVERLAY> kann ein Overlay-Label sein, ein Overlay-Pfad (Maske) oder eine Zahl.
.TP
.BI "--print-overlay-label " OVERLAY
Gibt das Lebel des ersten Overlays aus, der auf I<OVERLAY> zutrifft.
I<OVERLAY> kann ein Overlay-Label sein, ein Overlay-Pfad (Maske) oder eine Zahl.
.TP
.B --print-all-useflags
Gibt alle IUSE-Worte aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-keywords
Gibt alle KEYWORDS aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-slots
Gibt alle SLOT-Strings aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-licenses
Gibt alle LICENSE-Strings aus, die in irgendeiner Version benutzt werden.
.TP
.B --print-all-depends
Gibt alle Worte aus, die in einem B<{,R,P}DEPEND> auftauchen.
Die geht nur, falls B<DEP=true> aktiv ist (und bei der Erzeugung der Cachedatei aktiv war).
.TP
.B --print-world-sets
Gibt die world sets aus.
.TP
.B --is-current
Diese Option überprüft nur, ob B<@EIX_CACHEFILE@> vorhanden und zulässig ist
(d.h. in einer Version, die von B<eix> gelesen werden kann).
In diesem Fall kehrt eix erfolgreich zurück, ohne irgendetwas auszugeben.
.\" }}}

.\" {{{ -------- Ausgabe-Optionen
.SS Ausgabe-Optionen
.TP
.BR -x ", " --versionsort "    (toggle)"
Gibt die vorhandenen Versionen sortiert nach Versionen (oder Slots) aus.
Bei Slot-sortierter Ausgabe wird jeder Slot in einer neuen Zeile ausgegeben.
Dieser Modus kann mit B<--versionlines> (B<-l>) kombiniert werden,
um für jede neue Version eine neue Zeile auszugeben.
.TP
.BR -l ", " --versionlines "   (toggle)"
Gibt die vorhandenen Versionen in einer (vertikalen) Liste aus.
Nur in diesem Modus werden gewisse Zusatzinformationen für jede Version ausgegeben.
Genauer, je nachdem ob B<--verbose> benutzt wird und abhängig vom Status der
Konfigurationsvariablen B<VERSION_{IUSE,KEYWORDS,DEPS}_{NORMAL,VERBOSE}>
kann dies B<KEYWORDS>, B<IUSE>, B<DEPEND>, B<RDEPEND>, B<PDEPEND> sein.
Beachten Sie: Falls B<IUSE> nicht für jede Version ausgegeben wird, so wird es
nur gesammelt für das gesamte Paket ausgegeben, was einen falschen Eindruck geben kann,
da sich B<IUSE> von Version zu Version zuweilen dramatisch ändert.
.TP
.BR -c ", " --compact "   (toggle)"
Wählt ein kompaktes Layout für die Ausgabe von Suchergebnissen.
Nützlich, um einen besseren Überblick über eine lange Ergebnisliste zu erhalten,
und es hilft auch, die Suche über eine lansame Verbindung (wie etwa eine serielle Konsole)
zu beschleunigen.
.TP
.BR -v ", " --verbose "   (toggle)"
Benutzt ein ausführliches Layout mit zusätzlichen Informationen über Suchergebnisse
(wie etwa die Lizenz eines Pakets).
.TP
.BR --xml "   (toggle)"
Ausgabe im XML format.
Falls dies für ein externes Programm geschieht, empfiehlt sich zusätzlich
die Benutzung von B<--care> und das Exportieren einiger Variablen wie B<LOCAL_PORTAGE_CONFIG>,
so dass Benutzereinstellungen die Ausgabe nicht beeinflussen.
Mit dieser option werden B<OVERLAYS_LIST=none> und B<--pure-packages>
automatisch aktiviert.
Das Ausgabeformat kann minimal mit den B<XML_*>-Variablen beeinflusst werden.
Das benutzte XML-Format ist auf menschenlesbare Art in den Dateien eix-xml.html oder eix-xml.txt
dokumentiert und auf weniger menschenlesbare Art (nämlich als XML-Schema) in der Datei eix-xml.xsd

.TP
.BR -* ", " --pure-packages "   (toggle)"
(bei der Benutzung der Kurzform in einer Shell bitte das Quoten nicht vergessen!)
Diese Option verhindert die Ausgabe zusätzlicher Informationen (Overlay-Namen, Zahl der gefundenen Pakete) am Ende.
Dies kann für Shell-Skripte nützlich sein, die die Ausgabe parsen.
.TP
.BR --only-names "   (toggle)"
Wie "-*", aber zusätzlich werden nur Kategorie und Name der gefundenen Pakete ausgegeben.
.TP
.BR -0 ", " --brief "   (toggle)"
Ausgabe von höchstens einem Paket.
Diese Option ist normalerweise schneller, wenn sie mit B<COUNT_ONLY_PRINTED=false> kombiniert wird.
In diesem Fall und zusammen mit Fuzzy-Suche wird nicht notwendigerweise der beste Treffer ausgegeben.
.TP
.BR --brief2 "   (toggle)"
Wie B<--brief>, aber Ausgabe von bis zu zwei Paketen.
.\" }}}

.\" {{{ -------- Optionen für eix
.SS Spezielle Optionen für B<eix>
.TP
.BR -t ", " --test-non-matching
Vor anderer Ausgabe werden Einträge in /etc/portage/package.* ausgegeben,
die kein passendes Pendant in der Paketdatenbank haben, oder die offensichtlich
keine Bedeutung haben, weil sie leer sind (siehe B<TEST_FOR_EMPTY>).

Diese Option listet ebenfalls alle installierten Pakete, deren Name nicht
in der Datenbank zu finden ist.

Dies ist etwas prinzipiell anderes als B<-T> (siehe unten).
Das letztere überprüft nur für Pakete B<in der Datenbank>, ob redundante
Einträge in /etc/portage/package.* existieren bzw. ob die installierten Versionen
vorhanden sind.

Am besten wird diese Option mit B<-T> kombiniert, um /etc/portage/package.* aufzuräumen.

Oder sie kann mit B<-e> kombiniert werden, um weitere Ausgaben zu verhindern.

Falls es einen Grund gibt, bestimmte Einträge/Pakete von diesem Test auszuschließen,
können diese Einträge in eine Datei /etc/portage/package.*.nonexistent eingefügt werden.
Hier steht * für eines der Wort keywords, mask, unmask, use, env, license, cflags, installed.
Diese Dateien (und wie ihre Namen geändert werden können) wird später beschrieben.
.TP
.BI "--cache-file " FILE
Benutzt I<FILE> statt B<@EIX_CACHEFILE@>.

.\" {{{ -------- Optionen für AUSDRUCK
.SS Optionen für AUSDRUCK
AUSDRUCK wird benutzt um die Suche zu spezifizieren.

Ein AUSDRUCK kann Boolesche Operatoren und Tests gemäß der folgenden Grammatik enthalten:

AUSDRUCK ::= [ B<--not> | B<-!> ] KLAMMER_ODER_TEST |
               AUSDRUCK [ B<--and>| B<-a> ] AUSDRUCK |
               AUSDRUCK [ B<--or> | B<-o> ] AUSDRUCK

KLAMMER_ODER_TEST ::= B<--open>|B<-(> AUSDRUCK B<--close>|B<-)> |
               TEST_MIT_OPTIONEN

TEST_MIT_OPTIONEN ::= [TEST_OPTIONEN] [SUCHMUSTER]

Bitte vergessen Sie nicht, dass B<!>, B<(>, B<)> in Shells normalerweise gequotet werden müssen,
damit eix sie als Teil des Arguments erhält!

Falls ein AUSDRUCK mit B<-> beginnen soll, stellen Sie einfach zwei weiter B<--> Zeichen davor:
Auf diese Weise wird der AUSDRUCK nicht als Option interpretiert und zwei zusätzliche B<--> Zeichen werden ignoriert.
Beispielsweise wird B<eix ---tool --or ---util> diejenigen Pakete ausgeben die B<-tool> or B<-util> enthalten.

Die Bedeutung der logischen Operatoren sollte mit folgenden Ausnahmen offensichtlich sein:

1. Falls weder B<--and>|B<-a> noch B<--or>|B<-o> zwischen zwei AUSDRÜCKEN auftauchen,
so wird eines von beiden implizit angenommen.
Ob dies B<-a> oder B<-o> ist, hängt vom Wert der Konfigurationsvariable B<DEFAULT_IS_OR> ab.

2. Die Operatoren B<-a> und B<-o> haben gleiche Bindungskraft und sind linksassoziativ.
Insbesondere liefert B<X -o Y -a Z> keinen Treffer, falls B<Z> keinen Treffer liefert.

3. B<--not>|B<-!> negiert nur das Ergebnis des unmittelbar folgenden KLAMMER_ODER_TEST.

4. Falls SUCHMUSTER weggelassen wird, ist der Default ein leeres SUCHMUSTER.
Beispielsweise wird B<eix> mit den Default-Settings ohne Argument alle Pakete
ausgeben, da der leere String in jedem Namen enthalten ist.
Andererseits sollte B<eix -e> (normalerweise) nichts ausgeben,
da kein Paketname (I<exakt>) leer sein sollte.

5. Beachten Sie, dass die Syntax bedeutet, dass das SUCHMUSTER stets einen Ausdruck beendet.
TEST_OPTIONEN nach SUCHMUSTER beginnt immer einen neuen Ausdruck
(d.h. ein implizites B<--and> oder B<--or> wird eingefügt, je nach B<DEFAULT_IS_OR>).
Insbesondere hat B<eix -e foo> eine andere Bedeutung als B<eix foo -e>.
Letzteres bedeutet das selbe wie B<eix foo --and -e> or B<eix foo --or -e>,
je nach B<DEFAULT_IS_OR>.

6. Beachten Sie, dass TEST_OPTIONEN mehrere Optionen enthalten kann.
Diese werden alle zugleich angewendet, d.h. in gewissem Sinne werden diese
Optionen logisch geklammert und mit B<and> kombiniert (unabhängig von B<DEFAULT_IS_OR>).
Dies ist etwas zweideutig, da SUCHMUSTER weggelassen werden kann.
Diese Zweideutigkeit wird so aufgelöst, dass aufeinanderfolgende TEST_OPTIONEN stets als
ein Teil eines einzige TEST_MIT_OPTIONEN aufgefasst werden.
Beispielsweise werden in B<eix -I -O -e foo> alle Optionen als Teil eines einzigen I<AUSDRUCK> interpretiert
(nicht als vier B<AUSDRUCK>-Argumente wie es etwas bei B<eix -I '' -O '' -e '' foo> der Fall wäre).
Andererseits wird das B<--not> in B<eix -I --not -e> nicht dazu führen, dass die darauffolgende
TEST_OPTION B<-e> als Teil eines neuen I<AUSDRUCK>s verstanden wird.
Andere Optionen als TEST_OPTIONEN oder logische Optionen (wie B<-!>, B<-(>, B<-)>, B<-a>, B<-o>) werden diesbezüglich ignoriert.
Beispielsweise wird B<eix -I -c -e> nur einen I<AUSDRUCK> erzeugen, da B<-c>
weder eine TEST_OPTION noch eine logische Option ist und daher bei der
Interpretation von I<AUSDRUCK> keine Rolle spielt.

7. TEST_OPTIONEN kann Dinge wie den B<Match-Algorithmus> oder die B<Operandenwahl> festlegen.
Alle diese Dinge beziehen sich B<only> auf den aktuellen TEST_MIT_OPTIONEN;
insbesondere sind sie nur für das nächste B<SUCHMUSTER> aktiv.

Beachtne Sie ebenfalls, dass es neben dieser AUSDRUCK Syntax auch einen
anderen Weg zur impliziten (allerdings langsamen) Paketwahl aufgrund
anderer Kriterien gibt: Nämlich, indem man  B<FORMATSTRING> (siehe unten)
mit entprechenden Konditionalen versieht, so dass es einen leeren String
für ungewünschte Pakete ausgibt.

Es folgen die zulässigen TEST_OPTIONEN:
.TP
.BR -I ", " --installed
Findet nur installierte Pakete.
Benutzen Sie dies bitte nicht als Ersatz für B<eix-installed -a>
(oder B<qlist -ICv> oder B<equery>), da es nicht das selbe ist:
Pakete, die installiert aber nicht mehr im Portage Tree (oder einem Overlay) sind,
werden auf diese Weise nicht gelistet.
Andererseits sollten Sie solche Pakete ohnehin besser nicht haben
(es ist besser, diese Pakete in einen Overlay zu kopieren, falls sie irgendwann einmal reinstalliert werden müssen).
Um solche Pakete zu finden, kann B<eix -te> benutzt werden (oder B<eix -tI> um beides auszugeben),
aber dabei ist zu beachten, dass eix -t nicht die üblichen B<FORMAT> rules auf diese Pakete anwendet.
Dies sollte daher besser nicht in Skripten benutzt werden (falls Sie nicht genau wissen, was Sie da tun).

Falls Sie diese Option unbedingt als einen Ersatz für equery in Skripten benuzten wollen,
dann werden Sie sie vermutlich mit einem der folgenden Optionen kombinieren wollen:

.B --format --only-names

.B --format '<installedversions:NAMEVERSION>' --pure-packages

.B --format '<installedversions:EQNAMEVERSION>' --pure-packages

.B --format '<installedversions:NAMESLOT>' --pure-packages

.B --format '<installedversions:NAMEASLOT>' --pure-packages

.B --format '<installedversions:DATESORT>' --pure-packages
.TP
.BR -i ", " --multi-installed
Findet nur Pakete, die in mindestens zwei verschiedenen Versionen installiert sind.
Normalerweise bedeutet dies, dass die Versionen geslotted sind (zumindest zu dem Zeitpunkt, als sie installiert wurden).
.TP
.BR -d ", " --dup-packages
Findet nur doppelte Pakete,
beispielsweise, falls sys-foo/bar im offiziellen Portage-Baum und im lokalen Overlay existiert.
Falls B<DUP_PACKAGES_ONLY_OVERLAYS> gesetzt ist (siehe unten), müssen die Pakete in verschiedenen lokalen Overlays liegen.
.TP
.BR -D ", " --dup-versions
Findet nur Pakete mit doppelten Versionen,
beispielsweise, wenn sys-foo/bar-0.2.1 im offiziellen Portage-Baum und im lokalen Overlay existiert.
Falls B<DUP_VERSIONS_ONLY_OVERLAYS> gesetzt ist (siehe unten), müssen die Ebuilds in verschiedenen lokalen Overlays liegen.
.TP
.BR -1 ", " --slotted
Findet nur Pakete mit einem nichttrivialen Slot, d.h. wenn Slot nichtleer ist und verschieden von "0".
.TP
.BR -2 ", " --slots
Findet nur Pakete mit mindesten zwei verschiedenen Slots.
Anders als bei -1 wird hierbei ein Paket nicht gezeigt, falls nur ein Slot vorhanden ist, der z.B. den Slotnamen "4.3" trägt.
.TP
.BR -u ", " --upgrade ", " --upgrade+ ",  " --upgrade-
Findet nur Pakete, die zumindest eine Version aus einem Slot installiert haben,
die nicht die beste innerhalb des Slots ist.
Dies bedeutet normalerweise, dass ein Upgrade/Downgrade des Pakets notwendig ist.

Dieser Test berücksichtigt auch B<UPGRADE_TO_HIGHEST_SLOT> (siehe unten).

Für <--upgrade+> oder B<--upgrade-> verhält sich der Test, als wenn B<LOCAL_PORTAGE_CONFIG> B<true> bzw. B<false> ist.
Undernfalls wird diese Entscheidung von B<UPGRADE_LOCAL_MODE> gefällt.

Falls Sie nur Pakete mit Downgrade-Empfehlung sehen wollen, können Sie
die später beschriebenen B<FORMATSTRING>-Features benutzen.
.TP
.BR --stable ", " --testing ", " --non-masked ", " --system
Findet nur Pakete, die zumindest eine Version haben, die stabil (und nicht-maskiert),
testing oder stabil (und nicht maskiert), nicht-maskiert, bzw. in @system ist.
Falls mehrere dieser Optionen in einem Test kombiniert werden, muss die selbe Version
allen Kriterien genügen.
.TP
.BR --stable+ ", " --testing+ ", " --non-masked+ ", " --system+
Wie eben, nur dass sich der Test so verhält, als wenn  B<LOCAL_PORTAGE_CONFIG=true> gesetzt wäre.
.TP
.BR --stable- ", " --testing- ", " --non-masked- ", " --system-
Wie eben, nur dass sich der Test so verhält, als wenn  B<LOCAL_PORTAGE_CONFIG=false> gesetzt wäre.
.TP
.BR --installed-unstable ", " --installed-testing ", " --installed-masked
Findet nur Pakete, die zumindest eine nicht-stabile, testing, oder maskierte
Version installiert haben (der Test verhält sich, als wenn
B<LOCAL_PORTAGE_CONFIG=false> gesetzt wäre).
Falls mehrere dieser Optionen in einem Test kombiniert werden, muss die
selbe Version alle Kriterien erfüllen.
.TP
.BR --world
Findet nur Pakete aus @world.
Dies ist analog zu "emerge @world", d.h. es enthält nicht nur die Pakete aus
der world-Datei sondern auch aus world_set und das @system Set.
Falls dies nicht alles enthalten sein soll, gibt es alternative Optionen.
.TP
.BR --world-file
Findet nur Pakete aus der world-Datei oder aus dem @system Set.
.TP
.BR --world-set
Findet nur Pakete aus world_set oder den @system Set.
This only matches packages from world_set or from the @system set.
.TP
.BR --selected
Findet nur @selected Pakete.
Dies ist analog zu "emerge @selected", d.h. es enthält nicht nur Pakete im
world-Datei sondern auch in world_sets (falls @system in world_set enthalten
ist, ist das Verhalten natürlich identisch zu B<--world>).
Falls dies nicht alles enthalten sein soll, gibt es alternative Optionen.
.TP
.BR --selected-file
Findet nur Pakete aus der world-Datei.
.TP
.BR --selected-set
Findet nur Pakete aus world_set.
.TP
.BR --binary
Findet nur Pakete mit einem Binärfile (*.tbz2) in PKGDIR.
Die Version des Binärfiles muss mit mindestens einer vorhandenen oder einer installierten Version übereinstimmen.
(Falls keine Version vorhanden ist, kann das Paket ebenfalls nicht gefunden werden).
Nur die reine Existenz eines entsprechenden *.tbz2-files wird überprüft:
Ob Portage die Datei tatsächlich benutzen kann, hängt auch von Meta-Daten innerhalb der *.tbz2-Datei ab (wie etwa USE settings), was von eix nicht beachtet wird.
.TP
.BR -O ", " --overlay
Findet nur Pakete mit mindestens einer Version in einem Overlay.
.TP
.BI "--in-overlay " overlay
Findet nur Pakete mit mindestens einer Version in einem Overlay, der auf B<overlay> passt.

Falls diese Option wiederholt wird, werden die zusätzlichen I<overlay>-Argumente
zu einer Liste zulässiger Overlays zusammengefasst.

I<overlay> kann entweder ein Wildcard-Muster oder eine Zahl sein.
Beachten Sie, dass sie mit der Default-Einstellung B<OVERLAYS_LIST=all-used-renumbered>
nicht die korrekten Overlay-Nummern sehen; für eine Liste der korrekten Overlay-Nummern
können Sie beispielsweise den Aufruf

B<OVERLAYS_LIST=all eix --not>

oder in Skripten besser

B<OVERLAYS_LIST=all PRINT_COUNT_ALWAYS=never eix -!>

benutzen.
Die speziellen Werte B<0> oder B<$PORTDIR> passen auf den Hauptbaum (der
in diesem Zusammenhang als der 0-te Overlay betrachtet wird).

Falls I<overlay> leer ist (or weggelassen wird, falls B<--in-overlay>
die letzte Option war) dann passen alle Overlays außer dem Hauptbaum
(d.h. B<--in-overlay ''> ist das selbe wie B<-O>).
.TP
.BI "--only-in-overlay " overlay
Findet nur Pakete, die nur Versionen haben, die in einem Overlay liegen,
der auf I<overlay> passt.

Falls diese Option wiederholt wird, werden die zusätzlichen I<overlay>-Argumente
zu einer Liste zulässiger Overlays zusammengefasst.

I<overlay> kann entweder ein Wildcard-Muster oder eine Zahl sein, analog wie in B<--in-overlay>.
Insbesondere findet B<--only-in-overlay ''> alle Pakete, die nicht im Hauptbaum
sondern nur in Overlays liegen.
.TP
.BR -J ", " --installed-overlay
Findet nur Pakete, die aus einem Overlay installiert wurden.
Für vollkommen zuverlässige Ergebnisse sollte B<CHECK_INSTALLED_OVERLAYS=true>
gesetzt werden (was nicht der Default ist, weil es Tests massiv verlangsamt).
Siehe B<CHECK_INSTALLED_OVERLAYS> für Details.
.TP
.BI "--installed-from-overlay " overlay
Dies ist analog zu B<--in-overlay> mit dem Unterschied, dass nur
Pakete gefunden werden, die zumindest eine Version aus I<overlay> installiert haben.
Beispielsweise wird B<--installed-from-overlay 0> nur die Pakete finden,
bei denen zumindest eine Version aus dem regulären Portage-Baum installiert ist.
Wie für -J sollte B<CHECK_INSTALLED_OVERLAYS=true> gesetzt werden, um
vollständig zuverlässige Ergbnisse zu erhalten.
.TP
.B --installed-in-some-overlay
Findet nur Pakete, die zumindest eine Version installiert haben, die
auch in einem Overlay zu finden ist.
.TP
.BI "--installed-in-overlay " overlay
Dies ist analog zu B<--in-overlay> mit dem Unterschied, dass nur Pakete gefunden
werden, die zumindest eine installierte Version in I<overlay> haben.
Beispielsweise wird B<--installed-in-overlay 0> nur Pakete finden, die mindestens
eine Version installiert haben, die es im regulären Portage-Baum gibt.
.TP
.B --restrict-fetch
Findet nur Pakete, die zumindest eine Version mit RESTRICT=fetch haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-mirror
Findet nur Pakete, die zumindest eine Version mit RESTRICT=mirror haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-primaryuri
Findet nur Pakete, die zumindest eine Version mit RESTRICT=primaryuri haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-binchecks
Findet nur Pakete, die zumindest eine Version mit RESTRICT=binchecks haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-strip
Findet nur Pakete, die zumindest eine Version mit RESTRICT=strip haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-test
Findet nur Pakete, die zumindest eine Version mit RESTRICT=test haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-userpriv
Findet nur Pakete, die zumindest eine Version mit RESTRICT=userpriv haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-installsources
Findet nur Pakete, die zumindest eine Version mit RESTRICT=installsources haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-bindist
Findet nur Pakete, die zumindest eine Version mit RESTRICT=bindist haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --restrict-parallel
Findet nur Pakete, die zumindest eine Version mit RESTRICT=parallel haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-interactive
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=interactive haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-live
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=live haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-virtual
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=virtual haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.B --properties-set
Findet nur Pakete, die zumindest eine Version mit PROPERTIES=set haben.
Falls dies mit anderen PROPERTIES/RESTRICT tests kombiniert wird, muss die selbe Version alles gleichzeitig erfüllen.
.TP
.BR -T ", " --test-obsolete
Findet nur obsolete Pakete.

Pakete sind obsolete, wenn sie redundante Einträge in /etc/portage/package.*
haben (falls B<TEST_FOR_REDUNDANCY> gesetzt ist), oder falls nicht alle
installierten Versionen existieren (falls B<TEST_FOR_NONEXISTENT> gesetzt ist).

Was als redundant gilt, wird durch die unten beschriebenen <REDUNDANT_IF>-Variablen festgelegt,
und was als nicht-existent betrachtet wird, wird durch die B<NONEXISTENT_IF>-Variablen festgelegt.
Der Test für Versionen von obsoleten Overlays funktioniert nur dann zuverlässig,
wenn B<CHECK_INSTALLED_OVERLAYS=true> gesetzt ist (was nicht der Default ist,
weil es Tests dramatisch verlangsamt).
Siehe B<CHECK_INSTALLED_OVERLAYS> für Details.

Beachte, dass diese Option nur Pakete in der Datenbank test.
Insbesondere werden keine Einträge für beispielsweise umbenannte oder aus dem Portage-Baum gelöschte Pakete
mit dieser Option gefunden werden.
Letzteres wird mit der Option B<-t> bedient.

Daher wird diese Option am Besten mit -t kombiniert, wenn auch andere Arten obsoleter Einträge gefunden werden sollen.

Falls es einen Grund gibt, bestimmte Pakete von diesem Test auszuschließen,
so können diese Einträge in die Datei (oder Verzechnis) /etc/portage/package.nowarn geschrieben werden.
Diese Datei (und wie alternative/zusätzliche Dateien angegeben werden können) wird später beschrieben.
.TP
.BR -| ", " --pipe
(Beachten Sie, dass die Shell normalerweise kein B<|>-Zeichen übergibt, wenn es
nicht gequotet ist).

Findet nur Pakete aus Standard-Input; normalerweise wird dies in einer Pipe benutzt,
etwa als Ausgabe von emerge -pv (oder genlop -p).
Tatsächlich werden im Input nur Worte (durch Leerzeichen oder Zeilenende separiert) beachtet,
die im folgenden Format sind:

I<category>B</>I<package>B<->I<version> oder

I<category>B</>I<package>

Zusätzlich werden alle passenden Pakete/Versionen in der Ausgabe als markiert behandelt.
Details zu Letzterem stehen in der Beschreibung der B<marked> und B<markedversions:*> Formatstrings.

Auchwenn B<--pipe> mehr als einmal auftaucht, wird die Standard-Eingabe natürlich nur einmalig gelesen,
aber wiederholt für jedes Auftauchen interpretiert (d.h. falls der erste --pipe Ausdruck passt,
werden auch alle anderen passen).

Falls der Standard-Input nur zum Markieren aber nicht zur Auswahl benutzt werden soll,
kann etwa folgender Ausdruck benutzt werden:

B<eix irgendwas -a "-(" --pipe -o "-)">
.\" }}}

.\" {{{ -------- Operandenwahl
.SS Operandenwahl
.TP
Die nachfolgenden Optionen legen die Felder fest, auf die SUCHMUSTER passen soll.
Mehrere Felder können in einem Ausdruck festgelegt werden (der Ausdruck passt,
falls das Suchmuster auf mindestens eines der spezifierten Felder passt).
Falls keine diese Optionen angegeben wird, wird der Default anhand einer
Heuristik gewählt, die von der Form von SUCHMUSTER abhängt.
In den meisten Fällen wird das Default-Feld B<--name> sein, aber wenn das
SUCHMUSTER "speziell" aussieht, etwa "cat/n" oder "@set", so wird das Default-Feld
auf B<--category-name>, B<--set>, B<--description>, B<--homepage> oder B<--license> geändert.
Details der Heuristik werden in der später erklärten B<DEFAULT_MATCH_FIELD>-Konfigurationsvariable festgelegt.
.TP
.BR -y ", " --any
Jedes Feld wird durchsucht.
Dies ist gleichbedeutend damit, gleichzeitig alle Optionen B<--name>, B<--description>, B<--category>, ... anzugeben.
Man wird dies immer dann wählen, wenn man sicher sein möchte, keine Treffer zu übersehen.
Man sollte allerdings damit rechnen, dass die Trefferliste viel länger als erwartet sein wird.
(Wer neugierig ist, kann mit den Optionen B<-vl> and Weiterleitung nach grep
den oft unerwarteten Grund herausfinden, weshalb ein Treffer bei B<-y> auftaucht).
Um zumindest den Abhängigkeitsstring von der Suche auszunehmen, empfiehlt sich manchmal
die Kombination mit B<DEP=false>, z.B.

B<DEP=false eix --any SIP>

.TP
.BR -s ", " --name
z.B. "eix"
.TP
.BR -S ", " --description
z.B. "Small utility for searching .."
.TP
.BR -C ", " --category
z.B. "app-portage"
.TP
.BR -A ", " --category-name
z.B. "app-portage/eix"
.TP
.BR -H ", " --homepage
z.B. "@PACKAGE_URL@"
.TP
.BR -L ", " --license
z.B. "GPL-2"
.TP
.BR --deps ", " --depend ", " --rdepend ", " --pdepend
Dieser Test kann nur dann etwas finden, wenn B<DEP=true> benutzt wird
(und B<DEP=true> bei der Erzeugung des Cachedatei benutzt wurde).
Er tested gegen B<DEPEND>, B<RDEPEND> bzw. B<DEPEND>
(oder mit B<--deps> gegen irgendeines davon) für irgendeine Version des Pakets.
B<--deps> ist das gleiche wie B<--depend> B<--rdepend> B<--pdepend>.
Beachten Sie, dass gegen den String ohne irgendwelche Interpretatino oder
Modifikation getestet wird; nur Wort-Trenner werden einzelne Leerzeichen.
Insbesondere kann der String, gegen den getestet wird, so aussehen:

app-admin/fam nls? ( sys-devel/gettext ) =dev-libs/apr-1* !!dev-db/libpq

Daher ist der Test tatsächlich nicht nur gegen abhängige Pakete, sondern
auch gegen Blocker und/oder Konditionale und gegen verschiedene Möglichkeiten,
Versionen zu spezifizieren.
.TP
.BR --set
Name eine lokalen Paket-Sets oder Version in der Datenbank
(d.h. entsprechend einer Datei aus B</etc/portage/sets>, B</etc/portage/sets.eix>,
oder eines anderen Verzeichnisses ausB<EIX_LOCAL_SETS_ADD>; siehe die Kommentare zu B<EIX_LOCAL_SETS>).
Die "system" und "world" sets sind hier bewusst ausgeshlossen, da Letzteres mit
B<--system[+-]>, B<--world>, B<--world-all> oder B<--world-sets> getestet werden sollte.
.TP
.B --slot
Slotname einer Version in der Datenbank, z.B. "kde-4"
.TP
.B --installed-slot
Slotname einer installierten Version.
Beachten Sie, dass ohne die Option B<--care> (oder B<CAREMODE=true>) der Slotname ev. nur vermutet wird.
.TP
.BR -U ", " --use
Ein Useflag, das im IUSE mindestens eines Ebuilds von einer Version des Pakets festgelegt wird.
Normalerweise wird diese Option mit -e kombiniert.
.TP
.B --installed-with-use
Ein Useflag, das während der Installation eines Pakets aktiv ist.
Natürlich kann dieser Test nur dann erfolgreich sein, wenn das Paket installiert ist.
Es gelten die selben Einschränkungen wir für B<-I>, d.h. nur diejenigen Pakete werden gefunden,
die es noch in der Datenbank gibt.
.TP
.B --installed-without-use
Ein Useflag, das während der Installation eines Pakets inaktiv ist.
Natürlich kann dieser Test nur dann erfolgreich sein, wenn das Paket installiert ist.
Es gelten die selben Einschränkungen wir für B<-I>, d.h. nur diejenigen Pakete werden gefunden,
die es noch in der Datenbank gibt.
.\" }}}

.\" {{{ -------- Match-Algorithmus
.SS "Match-Algorithmus"
Die folgenden Optionen legen den Algorithmus fest, nach dem das Testfeld gegen das SUCHMUSTER
getestet werden soll.
Nur ein Algorithmus kann pro AUSDRUCK gewählt werden.
Falls keine dieser Optionen benutzt wird, wird der Default anhand einer
Heuristic ausgewählt, der von der Gestelt der Suchmusters abhängt.
In den meisten Fällen, wird dieser Default B<--regex> sein, außer wenn das
Suchmuster aussieht wie "typischerweise" ein glob-Muster or ein Teilstring
(in diesem Fall wird der entsprechende Algorithmus der Default), oder falls
das Suchmuster einen speziellen Inhalt wie "@set" oder "cat/n" hat, in welchem
Fall die meisten Leute erwarten, dass gegen den gesamten String bzw, gegen
den Stringanfang getestet wird.
Details der Heuristik werden in der später erklärten B<DEFAULT_MATCH_ALGORITHM>-Konfigurationsvariable festgelegt.
.TP
.BR -e ", " --exact
Das Suchmuster ist ein exakter (ganzer) String.
Beispielsweise zeigt "eix -e gcc" nur Pakete des namens "gcc".
.TP
.BR -b ", " --begin
Das Suchmuster ist ein Stringanfang.
Beispielsweise zeigt "eix -b gcc" die Pakete mit dem Namen "gcc", aber
beispielsweise auch "gcc-config".
.TP
.BR --end
Das Suchmuster ist ein Stringende.
.TP
.BR -z ", " --substring
Das Suchmuster taucht irgendwo im String auf.
.TP
.BR -f " [" I<N> "], " --fuzzy " [" I<N> "]"
Fuzzy-Suche mit dem maximalen Levenshtein-Abstand I<N> (default @LEVENSHTEIN_DISTANCE@) für den ganzen String.
Diese Option reduziert die Suchgeschwindigkeit.
.TP
.BR -p ", " --pattern
Das Suchmuster ist ein Wildcard-pattern (gegen desn gesamten String. Siehe
.BR fnmatch (3)
und/oder
.BR glob (7)
für weitere Details.
Vorsicht bei der Übergabe des Suchmusters in einer Shell (Quoting!).
.TP
.BR -r ", " --regex
Das Suchmuster ist ein regulärer Ausdruck.
Nur ein Teilstring muss passen (außer wenn ^ oder $ benutzt werden).
Das leere Suchmuster passt auf alles.
Weitere Informationen finden sich in
.BR regex (7).
Vorsicht bei der Übergabe des Suchmusters in einer Shell (Quoting!).
.\" }}}
.\" {{{ -------- Layouts festlegen
.SS Layouts festlegen \fP(siehe B<FORMATSTRING> weiter unten)
.TP
.BR --format " " I<FORMAT>
Define das normale Layout zur Ausgabe als I<FORMAT>
.TP
.BR --format-compact " " I<FORMAT>
Define das kompakte Layout zur Ausgabe als I<FORMAT>
.TP
.BR --format-verbose " " I<FORMAT>
Define das ausführliche Layout zur Ausgabe als I<FORMAT>
.\" }}}
.\" }}}
.\" {{{ -------- Options for eix-update
.SS Spezielle Optionen für B<eix-update>
.TP
.BR -H ", " --nostatus
Kein Update der Statuszeile.
.TP
.BR --force-status
Update der Statuszeile, selbst wenn die Ausgabe kein Terminal ist
oder falls TERM nicht mit einem Wort aus TERM_STATUSLINE beginnt.
.TP
.BR  -o " " I<Ausgabedatei> ", " --output " " I<Ausgabedatei>
Mit dieser Option schreibt B<eix-update> die eix-Datenbank nach I<Ausgabedatei>
statt B<@EIX_CACHEFILE@>.
Mit dieser Option wird die gesetzte B<umask> berücksichtigt.
Andernfalls wird die B<umask> zwangsläufig auf B<002> zur Erzeugung der Datei gesetzt.
.TP
.BR  -a " " I<Overlay> ", " --add-overlay " " I<Overlay>
Dies ist ähnlich wie I<Overlay> to B<PORTDIR_OVERLAY> zu /etc/make.conf
oder zu B<ADD_OVERLAY> hinzuzufügen, hat aber den Vorteil,
dass Letztere nicht modifiziert werden müssen, und dass es problemlos
möglich ist, Leerzeichen in I<Overlay> zu benutzen.
Overlays mit dieser Option kommen nach Overlays aus B<KEEP_VIRTUALS>.
Falls I<Overlay> bereits in der Liste der Overlays enthalten ist, so hat diese
Option keine Auswirkingen.
Es ist ausdrücklich zulässig, diese Option wiederholt zu benutzen,
um mehrere Overlays hinzuzufügen.

.TP
.BR -x " " I<Overlay> ", " --exclude-overlay " " I<Overlay>
Dies ist ähnlich wie I<Overlay> to B<EXCLUSE_OVERLAY> hinzuzufügen,
hat aber den Vorteil, dass Letzteres nicht modifiziert werden muss,
und dass es problemlos möglich ist, Leerzeichen in I<Overlay> zu benutzen.
I<Overlay> wird als Maske aufgefasst.
Alle passenden Overlays (auch diejenigen, die später mit B<--add-overlay>
hinzugefügt wurden), werden aus der Liste der Overlays ausgeschlossen.
Das B<PORTDIR>-Verzeichnis wird als ein weitere Overlay betrachtet,
der ausgeschlossen werden kann (in diesem Fall wird der erste I<Overlay>
der Liste als B<PORTDIR> gespeichert).
Es ist ausdrücklich zulässig, diese Option wiederholt zu benutzen,
um mehrere Overlays auszuschließen.
.TP
.BR -m " " I<Overlay> " " I<Methode> ", " --override-method " " I<Overlay> " " I<Methode>
Änder die Cache-Methode von I<Overlay>
(der B<PORTDIR>-Verzeichnis ist ein erlaubter I<Overlay>) auf I<Methode>.
I<Overlay> wird als Maske betrachtet, d.h. es darf Wildcards enthalten.
Falls I<Overlay> auf nichts in der Liste der Overlays passt, hat diese Option keine Auswirkungen.
Diese Option ist ähnlich wie das Hinzufügen des Eintrags "I<Overlay> I<Methode>"
am Ende der B<OVERRIDE_CACHE_METHOD>-Variablen.
Es ist ausdrücklich zulässig, die Option wiederholt zu benutzen, um
Cache-Methoden für verschiedene Overlays zu überschrieben.
Die zuletzt passende Überschreibung gewinnt.
Insbesondere kann man mit dieser Option den Inhalt von B<OVERRIDE_CACHE_METHOD> überschreiben.
.TP
.BR -r " " I<Overlay-Path> " " I<Overlay-Label> ", " --repo-name " " I<Overlay-Path> " " I<Overlay-Label>
Der Overlay I<Overlay-path> erhält das Lebel I<Overlay-Label>, unabhängig von anderen Settings.
Dies kann mit B<REPO_NAMES> überschrieben werden.
Im Gegensatz zu B<REPO_NAMES> ist I<Overlay-Path> kein Muster sondern ein genauer Pfad.
.TP
.BR -v " " --verbose
Gibt die effektiv benutzte Cache-Methode für jedes Ebuild aus.
Dies erzeugt eine Menge an Ausgaben und ist hauptsächlich zum Debuggen nützlich,
etwa wenn unklar ist, weshalb eix-update schneller/langsamer ist als erwartet.
.\" }}}

.\" {{{ AUSGABE
.SH AUSGABE
.SS Slots
Anders als in der üblichen Ausgabe von Versionen in emerge kann <eix>
auch Slotnamen ausgeben, wenn sie nichttrivial (leer oder "0") sind.
Ob dies geschieht, wird u.a. durch B<FORMATSTRING> festgelegt.

Falls Slots ausgegeben werden, wird der Slotname entweder mit einem
Doppelpunkt von der Versionsnummer abgetrennt, oder der Slotname wird
in Klammern geschrieben.
Der bevorzugte Modus wird in der Variable B<COLON_SLOTS> festgelegt.

Falls B<PROPERTIES> oder B<RESTRICT> im Ebuild gesetzt sind, wird dies
per Default im Versionsstring angezeigt; Details können durch Setzen
von Konfigurationsvariablen beeinflusst werden.

Einige Beispiele:
.TP
.BR 4.1.1:4.1 "   oder   " 4.1.1(4.1)
Dies ist Version 4.1.1, die in den Slot "4.1" installiert wird.
.TP
.BR 3.14p:GNAT-3.14p "   oder   " 3.14p(GNAT-3.14p)
Dies ist Version 3.14p, die in den Slot "GNAT-3.14p" installiert wird.
.TP
.B 2.0.0_rc1-r6
Dies ist Version 2.0.0_rc1-r6, und der SLOT ist leer oder "0".
.TP
.B 1.0*ilvs^fmpbstuidP{tbz2}
Dies ist Version 1.0, und gesetzt sind
PROPERTIES="interactive live virtual set" sowie
RESTRICT="fetch mirror primaryuri binchecks strip test userpriv installsources bindist parallel".
Darüberhinaus existiert eine *.tbz2 Datei (Binärpaket) für diese Version in B<PKGDIR>.
.TP
.B 5.0-r3(5.0R3)^f "   oder   " 5.0-r3:5.0R3^f
Dies ist Version 5.0-r3, die in Slot 5.0R3 installiert wird, und die RESTRICT="fetch" hat.

.SS Maskierung
Wer Gentoo für mehr als eine Woche benutzt hat, wird vermutlich sofort
das Format für die Maskierung von Versionen verstehen.
Nichtsdestotrotz wird es hier anhand einiger Beispiele erklärt.
Es wird natürlich nur die Default-Ausgabe beschrieben; Details können
durch Konfigurationsvariablen beeinflusst werden.
.TP
.B [P]2.95.3-r8
Eine Maske für das Paket wurde in der packages-Datei des Profiles gefunden,
aber diese Version passt nicht.
Portage nennt dies "masked by profile".
.TP
.B [M]4.0.0_alpha20050213
Die Version passt auf einen Eintrag aus /etc/portage/package.mask, $PORTDIR/profiles/package.mask
oder einer package.mask des Profiles.
Portage nennt dies "masked by package.mask".
.TP
.B [m]4.1.4
Die Version passt zu einer lokalen Maske (von /etc/portage/package.mask), aber sie ist
weder "masked by profile" noch in $PORTDIR/profiles/package.mask maskiert.
.TP
.B {P}2.95.3-r8
Die Version war ursprünglich "masked by profile", aber dies wurde lokal durch /etc/portage/profile/packages geändert.
.TP
.B {M}4.0.0_alpha20050213
Die Version war ursprünglich in $PORTDIR/profiles/package.mask, aber dies wurde lokal durch /etc/portage/package.unmask geändert.
.TP
.B *3.3.3
Die Version ist "masked by missing keyword", aber stabil für eine fremde Architektur.
.TP
.B ~*3.3.3
Die Version ist "masked by missing keyword", auf keiner Architektur stabil, aber auf einer fremden Architektur instabil.
.TP
.B **3.3.3
Die Version ist "masked by missing keyword" für alle Architekturen.
.TP
.B (**)3.4.3-r2
Die Version hatte ursprünglich kein Keyword, aber dies wurde lokal geändert (in /etc/portage/package.{accept_,}keywords oder durch ACCEPT_KEYWORDS).
.TP
.B -0.8.14
Maskiert durch -ARCH.
.TP
.B ~3.3.5.20050130
Die Version ist "masked by ~keyword".
.TP
.B (~)3.3.5.20050130
Die Verstion war ursprünglich "masked by ~keyword", aber dies wurde lokal geändert (in /etc/portage/package.{accept_,}keywords oder durch ACCEPT_KEYWORDS).
.TP
.B [M]~1.0.9626
Diese Version ist sowohl "masked by package.mask" als auch "masked by ~keyword".
.TP
.B [m](~)4.1.4-r1
Die Version was ursprünglich nur "masked by ~keyword", aber dies wurde lokale geändert (in /etc/portage/package.{accept_,}keywords oder durch ACCEPT_KEYWORDS).
Darüberhinaus wurde die Version lokal maskiert (in /etc/portage/package.mask).
.TP
.B 3.3.1
Dies schließlich ist eine stabile Version (die auch ohne lokale Settings stabil wäre).
.SS eix-diff
Die Ausgabe von B<eix-diff> wird vollständig durch Konfigurations-Variablen kontrolliert
(B<DIFF_FORMAT_NEW>, B<DIFF_FORMAT_DELETE>, B<DIFF_FORMAT_CHANGED> und eine Menge
Variablen die - zumindest im Default-Setting - durch diese über verzögerte Ersetzung benutzt werden, s. unten).
Die folggende Erklärung anhand von Beispielen kann daher nur das Verhalten
der Default-Settings der aktuellen eix-Versin beschreiben.
Obwohl dieses Default-Format lange Zeit unverändert blieb, wird keine
Stabilität der Defaults für zukünftige eix-Versionen garantiert.
.TP
.B "[N]   >> foo/bar (~1.0): description of foo/bar"
Das Paket B<foo/bar> ist neu im Baum.
.TP
.B "[*N]  >> foo/bar (1.0): description of foo/bar"
Das Paket B<foo/bar> ist neu im Baum.
Darüberhinaus hat as eine Version (1.0), die ohne Demaskieren/Keywording installiert werden könnte.
.TP
.B "      << foo/bar ({M}1.0): description of foo/bar"
B<foo/bar> wurde aus dem Baum entfernt; die vorherhige Version B<1.0> war maskiert, aber sie ist derzeit nicht mehr maskiert.
(wahrscheinlich, weil der Entwickler den entsprechenden Eintrag der package.mask-Datei zusammen mit der Löschung des Pakets entfernt hatte).
.TP
.B "[*>]   == foo/bar (1.0): description of foo/bar"
Der Status des Pakets B<foo/bar> im Baum hat sich geändert (für die lokalen Settings):
es hat eine Version (1.0) erhalten, die ohne lokales Demaskieren/Keywording installiert werden könnte,
währen der im vorherigen Baum foo/bar keine solche Version existierte. Darüberhinaus bedeutet das
.B >
dass ein Slot eine höhere Version erhielt. In diesem Fall ist tatsächlich die selbe Änderung für die beiden Symbole
.B >
und B<*> verantwortlich.
.TP
.B "[><]  == foo/bar (1.1(1) 2.0(2) -> 1.0(1) 2.1(2)): description"
Der Status des Pakets B<foo/bar> im Baum hat sich geändert (für die lokalen Settings):
Die Symbole an der linken Seite bedeuten, dass ein Slot eine höhere Version erhielt (die ohne Äderung von Maske/Keywords installiert werden könnte),
ein anderer Slot verlor eine solche "beste" Version.
Durch Betrachten der Versionsstrings wird klar, dass Slot B<2> eine neue Version erhielt
(die vorherige stabile dieses Slots war B<2.0>m die neue ist B<2.1>),
und das die vorherige höchste stabile Version B<1.1> des Slots B<1> entfernt oder maskiert wurde
(die aktuell stabile Version dieses Slots ist jetzt B<1.0>).
.TP
.B "[UD]  == foo/bar (1.1(1)@01.01.2009; 1.1(1) -> 2.0(2)): description"
Der Status des Pakets B<foo/bar> im Baum hat sich geändert (für die lokalen Settings):
Die Symbole an der linken Seite bedeuten, dass für einen installierten Slot ein Upgrade möglich ist (ohne Veränderung von Maske/Keywords),
und das ein anderer installierter Slot entfernt/maskiert wurde.
Durch Betrachten der Versionsstrings wird klar, dass die installierte Version B<1.1> des Slots B<1>
entfernt oder maskiert wurde, und dass es keine andere installierte Version des Slots B<1> gibt.
Eine stabile Version B<2.0> erschien neu im Slot B<2> (d.h. Slot B<2> existiere vorher nicht oder hatte keine stabile Version).

Da keine Version des Slots B<2> installiert war, kann eix in dieser Situation
nicht entscheiden, ob das Symbol "B<U>" wirklich angemessen ist:
Da eix keine Abhängigkeiten berücksichtigt, weiß es nicht, ob der neue Slot
beispielsweise von der world-Datei benutzt würde, oder ob es nur eine
Abhängigkeit für den alten Slot gibt.
Daher wird das Symbol "B<U>" in dieser Situation nur angezeigt, falls
B<UPGRADE_TO_HIGHEST_SLOT=true> or falls das Paket in
B</etc/portage/package.slot_upgrade_allow> gelistet ist.

Tatsächlich wäre der output
.B "[UD><] == foo/bar ..."
konsistenter, weil zusätzlich ein Slot eine höhere stabile Version erhielt
und die höchste stabile Version eines anderen Slots entfernt wurde.
Aber weil dies tyopischerweise von "B<U>" bzw. "B<D>" impliziert ist,
war es bei den Default-Settings eine Design-Entscheidung, dass bei der
Ausgabe von B<U> oder B<D> die Ausgabe der Symbole
.B <
bzw.
.B >
unterdrückt wird.
Natürlich ist es möglich, einen anderen B<DIFF_FORMAT_HEADER_CHANGED>-String
zu definieren, der einer anderen Politik folgt.
.\" }}}

.\" {{{ FORMATSTRING
.SH FORMATSTRING
.LP
Ein Formatstring kann konditionelle Blocks, Paketeigenschaften, Farben,
und normale Strings enthalten.
Wenn ein Formatstring zu einem Leerstring für ein Paket expandiert,
so wird auch der folgende Zielenumbruch nicht ausgegeben.
Daher kann man den gesamten Formatstring in einen konditionallen Block
packen, um nur nur die Pakete auszugeben, die der Bedingung entsprechen.
Ein Beispiel einer solchen "Umrahmung" wird weiter unten gegeben.
.\" {{{ -------- konditionelle Blocks
.SS konditionelle Blocks
Bedingungen sind sehr einfach: Eine Eigenschaft wird expandiert, und der
erhaltene String wird gegen einen anderen String getestet.
Wenn sie übereinstimmen, ist die Bedingung wahr, und der Block wird ausgeführt.
Bedingungen können negiert werden, so dass der else-Teil ausgeführt wird,
falls die Bedingung wahr ist, und der if-Teil, falls die Bedingung falsch ist.
Der else-Teil kann auch weggelassen werden.
.TP
.BR { [ ! ] I<EIGENSCHAFT> [ = I<RHS>] } I<TCODE> {}
Führt I<TCODE> aus, falls der String aus der Expansion von I<EIGENSCHAFT> gleich I<RHS> ist.
Das B<!> würde das Verhalten negieren.
.TP
.BR { [ ! ] I<EIGENSCHAFT> [ = I<RHS>] } I<TCODE> {else} I<FCODE> {}
Führt I<TCODE> aus, falls der string aus der Expansion von I<EIGENSCHAFT> gleich I<RHS> ist.
Andernfalls wird I<FCODE> ausgeführt.

I<RHS> ist entweder eine Eigenschaft (falls in <> eingeschlossen), eine variable
(falls ein $ vorgestellt ist), oder ein String (in allen anderen Fällen, oder falls in Anführungszeichen).

I<EIGENSCHAFT> kann entweder eine der unten spezifierten Paketeigenschaften sein
oder ein Variablenzugriff.
Ein Variablenzugriff hat die Gestalt B<$>I<VARIABLE>.
I<VARIABLE> muss nicht initialisiert werden; der Default-Inhalt ist der Leerstring.

Um I<VARIABLE> zur Laufzeit zu ändern, dient diese Syntax:
.TP
.BR { [ ! ] *I<VARIABLE> [ = I<RHS>] }
Dies sehr die Laufzeit-Variable B<VARIABLE> auf I<RHS>.
Mit B<!> ist das Ergebnis 1 oder leer, je nachdem ob I<RHS> leer ist.
Falls der zweite Teil (einschließlich des B<=>-Zeichens) weggelassen wird, gibt es eine spezielle Bedeutung:
B<{*>I<VARIABLE>B<}> setzt die I<VARIABLE> auf 1, B<{!*>I<VARIABLE>B<}> setzt die I<VARIABLE> auf den Leerstring.
.\" }}}

.\" {{{ -------- Paketeigenschaften
.SS Paketeigenschaften
Namen, die sich auf spezielle Eigenschaften des Pakets beziehen, das gerade ausgegeben wird.
Falls der Name benutzt werden soll, um eine Paketeigenschaft auszugeben, muss
der name B<in spitzen Klammern> geschrieben werden (d.h. "<name>").
.TP
.BR name ", " category ", " homepage ", " licenses
Name, Kategorie, Homepage and Lizenz des aktuellen Pakets.
.TP
.BR "availableversions:I<VARIABLE>" ", " "availableversions:I<VARIABLE>:I<VARSLOTS>"
Für jede Version wird der Inhalt der Konfigurations/Environment-Variablen B<VARIABLE>
ausgegeben, wobei diese als Formatstring interpretiert wird.
In der zweiten Form, und falls mindestens ein Slot des Pakets nichttrivial ist,
wird I<VARSLOTS> statt I<VARIABLE> benutzt, und die versionen werden entsprechend der Slots sortiert.

Um Missverständnisse zu vermeiden: Es ist nicht möglich, das gewünschte Format direkt nach dem Doppelpunkt anzugeben.
Statt dessen muss das gewünschte Format in einer neuen Variable gespeichert werden, und I<VARIABLE> und I<VARSLOTS>
sind nur die Namen dieser Variablen.

Nützliche Beispiele für I<VARIABLE> sind B<NAMEVERSION>, B<EQNAMEVERSION>,
B<EQNAMEVERSION>, B<ANAMESLOT>, B<ANAMEASLOT>, B<NAMESLOT>, B<NAMEASLOT> oder
B<DATESORT>.
Hierbei sind B<ANAMESLOT> und B<ANAMEASLOT> dazu gedacht, in der zweiten Form
benutzt zu werden, d.h. in B<availableversions:ANAMESLOT:ANAMESLOT> oder
B<availableversions:ANAMEASLOT:ANAMEASLOT> (Mnemonic: B<A>SLOT print slot B<a>lways).
B<NAMESLOT>, B<NAMEASLOT> und B<DATESORT> ist nur für installierte Versionen sinnvoll.
Siehe B<eix --dump> für die genaue Definition der Variablen.
.TP
.BR "markedversions:I<VARIABLE>" ", " "markedversions:I<VARIABLE>:I<VARSLOTS>"
Dies ist analog zu B<availableversions> mit dem Unterschied, dass nur
markierte Versionen ausgegeben werden.
.TP
.BR "bestversion:I<VARIABLE>" ", " "bestversion*:I<VARIABLE>" ", " "bestslotversions:I<VARIABLE>" ", " "bestslotversions*:I<VARIABLE>" ", " "bestslotupgradeversions:I<VARIABLE>" ", " "bestslotupgradeversions*:I<VARIABLE>"
Dies ist analog zu B<availableversions> mit dem Unterschied, dass nur die
beste Version bzw. die beste Version eines jeden Slots ausgegeben wird.
Für die Varianten mit B<*> werden auch unstabile Versionen akzeptiert.
Für die Varianten mit B<upgrade> werden nur diejenigen Versionen selektiert,
die voraussichtlich nach dem Upgrade erscheinen.
.TP
.B "installedversions:I<VARIABLE>"
Dies ist analog zu B<availableversions> mit dem Unterschied, dass nur
installierte Versionen ausgegeben werden.
.TP
.B "installedmarkedversions:I<VARIABLE>"
Dies ist analog zu B<installedversions> mit dem Unterschied, dass nur
markierte Versionen ausgegeben werden.
.TP
.BR first ", " last ", " slotfirst ", " slotlast ", " oneslot
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Diese Flags können benutzt werden um zu testen, ob gerade die erste oder letzte Version
eine Pakets ausgegeben wird (etwa um Zusatztext in diesen Fällen auszugeben).
Analog, wenn die Ausgabe nach Slot sortiert wird, kann damit getestet werden,
ob die aktuelle Version die erste oder letzte des aktuellen Slots ist,
oder ob es gar überhaupt nur einen Slot gibt.
Alle diese Eigenschaften sind leer, wenn die Bedingung nicht erfüllt ist, sonst 1.
Um die Wiederbenutzung von Code zu erleichtern gilt:
Wenn die Durckausgabe nicht Slot-sortiert ist, dann sind
B<slotfirst>/B<slotlast> äquivalent zu B<first>/B<last>, und B<oneslot> ist 1.
.TP
.BR slot ", " isslot ", " overlayver ", " overlaynum
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es wird der aktuelle Slot bzw. der Overlay der aktuellen Version ausgegeben.
B<overlayver> ist leer, falls das gesamte Paket aus nur einem Overlay stammt;
für diesen Fall sollte B<overlay> zur Ausgabe des Overlays benutzt werden.
Im Gegensatz dazu enthält B<overlaynum> stets die Nummer des Overlays
(als Text ohne Farben) oder ist leer, falls das Paket keinem Overlay entstammt.
B<isslot> tested nur, ob der Slot trivial ist und gibt in diesem Fall 1 aus
(sonst nichts).
.TP
.BR versionkeywords ", " versionkeywords* ", " versionekeywords
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Die vollen Keywords der aktuellen Version werden ausgegeben.
Falls die Daten durch das Profile modifiziert wurden, werden die
modifizierten Daten mit B<versionkeywords*> ausgegeben.
Die spezielle Form B<versionekeywords> gibt Letzteres aus falls es sich von
B<versionkeywords> unterscheidet; andernfalls ist es leer.
.TP
.BR isbestupgrade ", " isbestupgrade* ", " isbestupgradeslot ", " isbestupgradeslot*
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies expandiert zu 1, falls die aktuelle Version die beste bzw. beste des aktuellen Slots zum Upgraden ist.
Für die Varianten mit B<*> werden auch instabile Versionen berücksichtigt.
.TP
.BR installedversion ", " markedversion
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Expandiert zu 1 oder dem Leerstring, je nachdem ob die aktuelle Version installiert bzw. markiert ist.
.TP
.BR ishardmasked ", " washardmasked ", " isprofilemasked ", " wasprofilemasked ", " ismasked ", " wasmasked ", " isstable ", " wasstable ", " isunstable ", " wasunstable ", " isalienstable ", " wasalienstable ", " isalienunstable ", " wasalienunstable ", " ismissingkeyword ", " wasmissingkeyword ", " isminuskeyword ", " wasminuskeyword ", " isminusunstable", " wasminusunstable  ", " isminusasterisk ", " wasminusasterisk
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Expandiert zu 1 oder dem Leerstring, je nachdem ob die aktuelle Version (gemäß der
lokelen bzw. Default-Konfiguration) die entsprechend Stabilitätseigenschaft hat.
.TP
.B isbinary
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechende *.tbz2-Datei für die Version existiert.
.TP
.BR restrict ", " restrictfetch ", " restrictmirror ", " restrictprimaryuri ", " restrictbincheck ", " restrictstrip ", " restricttest ", " restrictuserpriv ", " restrictinstalledsources ", " restrictbindist ", " restrictparallel
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechendes B<RESTRICT>-Attribut für die Version gesetzt ist.
.TP
.BR properties ", " propertiesinteractive ", " propertieslive ", " propertiesvirtual ", " propertiesset
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Dies ist 1 oder leer, je nachdem ob eine entsprechendes B<PROPERTIES>-Attribut für die Version gesetzt ist.
.TP
.BR depend ", " rdepend ", " pdepend ", " depend* ", " rdepend* ", " pdepend*
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Die expandiert zum B<DEPEND>, B<RDEPEND>, bzw. B<PDEPEND> einer vorhandenen Version
(der String wird nach Möglichkeit abgekürzt, falls die Variante mit B<*> benutzt wird).
Die Expansion ist leer, falls B<DEP=true> nicht gesetzt ist (oder bei der Erzeugung der Datenbank nicht gesetzt war).
Bei der Ausgabe installierter Versionen (im Gegensatz zu vorhandenen Versionen)
ist diese Eigenschaft nicht verfügbar (d.h. sie ist leer).
Letzteres kann sich möglicherweise in einer zukünftigen Version von eix ändern.
.TP
.BR havedepend ", " haverdepend ", " havepdepend ", " havedeps
Wie oben mit dem Unterschied, dass nur 1 ausgegeben wird, wenn der
Wert des entsprechenden String bzw. mindestens eines davon nichtleer ist.
.TP
.BR haveuse ", " use
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Für verfügbare Versionen gibt B<use> die B<IUSE> Variable aus.
Für installierte Versionen gibt B<use> die B<USE>-Flags an, und ob sie installiert sind
(der Inhalt von B<FORMAT_BEFORE_SET_USE>, B<FORMAT_AFTER_SET_USE>, B<FORMAT_BEFORE_UNSET_USE>, B<FORMAT_AFTER_UNSET_USE>
wird an den entsprechenden Stellen ausgegeben).
B<haveuse> kann benutzt werden, um zu testen, ob die Ausgabe nichtleer ist (in diesem Fall ist die Ausgabe 1, sonst leer).
.TP
.BR "date:I<VAR>"
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es gibt die Installationszeit aus; das strftime()-Format für die Zeit wird aus der Variablen I<VAR> genommen.
.TP
.BR version
Dies darf nur in I<VARIABLE> im Zusammenhang von Versionsausgaben benutzt werden.
Es ist die reine Versionsnummer (als Text).
.TP
.BR installed ", " best ", " best*
Ist 1 oder leer, je nachdem of mindestens eine Version des Pakets installiert ist oder eine beste stabile bzw. instabile Version hat.
.TP
.B versionlines
Ist 1 oder leer, je nachdem ob --versionlines aktiv ist.
.TP
.B slotsorted
Ist 1 oder leer, je nachdem ob --versionsort aktiv ist.
.TP
.B color
Ist 1 oder leer, je nachdem, ob Farben/Markers ausgegeben werden.
Falls beispielsweise die Ausgabe auf ein Terminal erfolgt und keine anderweitige
Option angegeben wurde, ist die leer.
.TP
.BR setnames ", " allsetnames
Die Namen aller lokalen Sets, zu denen das Paket gehört, durch Leerzeichen separiert.
Mit B<allsetnames> ist auch das @system-Set dabei.
.TP
.B binary
Ist 1 oder leer, je nachdem, ob mindestens eine Version (verfügbar oder installiert) eine *.tbz2 Datei besitzt.
Vgl. die Bemerkungen zu B<--binary>.
.TP
.B overlaykey
Falls alle Versionen zum selben Overlay gehören, wird "[overlaykey]" mit entsprechcenden Farben ausgegeben.
.TP
.B system
1, falls das Paket zu @system gehört.
.TP
.B world
1, falls das Paket zur world-Datei gehört.
.TP
.B world_sets
1. falls das Paket zu world_sets gehört.
.TP
.B marked
1, falls das Paket mit der B<--pipe>-Option übergeben wurde.
Dies ist hauptsächlich für Tests sinnvoll.
.TP
.BR havemarkedversion
1 oder leer, je nachdem ob mindestens eine verfügbare Version des Pakets markiert ist.
Es ist möglich, dass ein Paket markiert wurde, obwohl keine der verfügbaren Versionen markiert wurden.
.TP
.BR slots ", " slotted
1, falls es mindestens zwei Slots bzw. mindestens einen nichttrivialen Slotnamen gibt.
.TP
.BR colliuse ", " havecolliuse
Die gesammelten IUSE-Flags (d.h. ihre Vereinigung) aller verfügbaren Versionen des Pakets, durch Leerzeichen separiert.
havecolliuse ist 1, falls colliuse nichtleer ist; dies ist schneller als colliuse.
.TP
.BR havebest ", " havebest*
1, falls das Paket eine beste stabile/instabile Version hat.
.TP
.BR upgrade ", " upgradeorinstall ", " downgrade ", " recommend ", " recommendorinstall
B<upgrade> ist 1, falls das Paket installiert ist und mindestens ein Slot ein Upgrade ermöglicht
(oder die beste stabile Version ist eine neuer Slot und B<UPDATE_TO_HIGHEST_SLOT> ist gesetzt).
Die anderen Variablen testen analog, ob für das Paket ein Upgrade oder frische Installation möglich ist,
ob ein Downgrade nötig ist, ob ein Up- oder Downgrade möglich/nötig ist,
bzw. ob ein Up- oder Downgrade oder Frischinstallation nötig/mölich ist.
Die Variable B<RECOMMEND_LOCAL_MODE> entscheidet, ob diese Tests B<LOCAL_PORTAGE_CONFIG> beachten.
.TP
.BR bestupgrade ", " bestupgradeorinstall ", " bestdowngrade ", " bestrecommend ", " bestrecommendorinstall
Wie oben mit dem Unterschied, dass nur die beste stabile Version des Pakets beachtet wird (und nicht alle Slots).
.TP
.BR better ", " worse ", " differ ", " bestbetter ", " bestworse ", " bestdiffer
Dies kann nur in Konditionaltests für B<DIFF_FORMAT_CHANGED> benutzt werden.
B<better> ist 1, falls das neue Paket einen neuen Slot oder eine besssere stabile Version
(or die gleiche beste stabile Version, aber von einem anderen Overlay) für einen Slot als das alte Paket hat.
B<worse> bedeutet analog, dass das alte Paket mindestens einen besseren Slot hatte
oder einen Slot, den es im neuen Paket nicht gibt.
B<differ> bedeutet, dass nicht alle besten stabilen Slots des alten und neuen Pakets übereinstimmen.
Die entsprechenden B<best*>-Versionen haben eine analoge Bedeutung mit dem Unterschied,
dass nur die beste stabile Version berücksichtigt wird (und nicht alle Slots).
Die Variable B<RECOMMEND_LOCAL_MODE> entscheidet, ob diese Tests B<LOCAL_PORTAGE_CONFIG> beachten.
.TP
.BR old... ", " new...
Dies kann nur in B<DIFF_FORMAT_CHANGED> benutzt werden.
Jedem Eigenschaftsname kann ein B<old> oder B<new> vorangestellt werden,
und der Wert entspricht dieser Eigenschaft, wobei die alten bzw. neuen Daten
benutzt werden.
Falls weder B<old> noch B<new> angegeben ist, wird die neue Version angenommen.
Beispielsweise gibt B<oldavailableversions:VAR> die vorerigen verfügbaren Versionen aus
(mit der Variablen B<VAR> als Ausgabeformat), während
B<newavailableversions:VAR> und B<availableversions:VAR> jeweils die
verfügbaren Versionen des aktuellen (d.h. neuen) Pakets ausgeben.
.\" }}}

.\" {{{ -------- Farben
.SS Farben
.TP
(I<NAME>,I<HELLIGKEIT>;I<MARKER>)
Jeder der ",I<HELLIGKEIT>" und ";I<MARKER>" Teile kann weggelassen werden.

Falls I<HELLIGKEIT> 1 ist, gibt eix die entsprechende 'light' (bold) Farbe für
I<NAME> aus, oder die normale Farbe, falls I<HELLIGKEIT> 0 ist.

Ein leerer I<NAME> bedeutet "default", und im Gegensatz zu "none" setzt er die
Ausgabe auf die Default-Farben (und ohne Marker).

Ein leerer (oder weggelassener) I<MARKER> bedeutet "none", d.h. keine
Attribut-Veränderung. Mehrere marker-Attributes können gleichzeitig
spezifiziert werden (mit "," unterteilt).

Verfügbare Farben:
I<default none black red green yellow blue purple cyan gray>

Verfügbare Marker:
I<none bold underline blink inverse>
.\" }}}

.\" {{{ -------- Beispiele
.SS Beispiele:

\fBFORMAT='{installed}(yellow,1;underline){else}(yellow,0){}<name>()}\\n' eix ...\fR

Falls das Paket B<...> installiert ist, wird der Name unterstrichen in Hellgelb ausgegeben,
sonst in normalem Gelb.

\fBFORMAT='<category>/<name><installedversions:INSTFORMAT>\\n' INSTFORMAT='{first}:{}<version><date:DATEFORMAT>{!last}\\n\\t{}' DATEFORMAT='%x' eix autom*\fR

Gibt für jedes B<autom*>-Paket den Kategoriennamen aus sowie, wenn das Paket installiert ist,
die installierten Versionen und die Installationszeit.
Man hätte das selbe Ergebnis auch durch Ersetzen von B<{!last}\\t\\n{}> durch B<{first}:{else}\\t\\n{}>
erreichen können, weil es natürlich auf dasselbe hinausläuft, ob B<\\t\\n> am Ende jeder Version
mit Ausnahme der letzten oder am Anfang jeder Version mit Ausnahme der ersten ausgegeben wird.

B<FORMAT='{downgrade}%{FORMAT_ALL}{}' eix -I>

Ausgabe aller installierten Pakete, für die es Downgrade-Empfehlungen gibt.
Beachte, dass B<FORMAT='{downgrade}%{FORMAT}{}'> nicht funktioniert, denn dies
wäre eine selbstreferenzierende Definition bei der verspäteten Ersetzung:
Natürlich kann eine Variable nicht durch eine Ersetzung durch sich selbst expandiert werden.
Aus diesem Grund ist der Inhalt der Variablen B<FORMAT> und ähnlicher Variablen sei eix-0.13.4
sehr einfach: Es ist einfach B<%{FORMAT_ALL}> (und analog für andere Variablen).
Daher kann man einfach die vollständige Definition des ursprünglichen Werts von B<FORMAT> einfügen
(was wir in obigem Beispiel getan haben).

Für kompakte Ausgabe ist es in obigem Beipsiel nicht möglich, einfach die Option B<-c>
zu benutzen, denn die Benutzung dieser Option hat nur den Effekt, dass
für den Formatstring die Variable B<FORMAT_COMPACT> statt B<FORMAT> benutzt wird.
Für kompakte Ausgabe, muss man also entweder

B<FORMAT_COMPACT='{downgrade}%{FORMAT_ALL_COMPACT}{}' eix -Ic>

benutzen, oder einfacher und mit dem gleichen Effekt:

B<FORMAT='{downgrade}%{FORMAT_ALL_COMPACT}{}' eix -I>
.\" }}}
.\" }}}

.\" {{{ DATEIEN
.SH "DATEIEN"
.LP
.\" {{{ -------- @SYSCONFDIR@/eix-sync.conf
.SS @SYSCONFDIR@/eix-sync.conf
Diese Datei enthält Kommandos und Konfigurationen für B<eix-sync>.
Kommentarzeilen beginnen mit B<#>.
Die Zeilen haben die folgende Gestalt und werden in der gegebenen Reihenfolge
vor B<emerge --sync> ausgeführt.

Beachten Sie, dass der Inhalt der Variablen B<EIX_SYNC_CONF> an diese Datei angehängt wird.
Per Default expandiert die Variable zu B<EIX_SYNC_OPTS>, so dass effektiv auch diese Variable an die Datei angehängt wird.
Beide Variablen können benutzt werden, ob die Defaults aus B<@SYSCONFDIR@/eix-sync.conf> zu modifizieren.
Machen Sie sich bitte bewusst, dass der Code dieser Zeilen bei B<eix-sync> innerhalb einer Shell mit "eval" ausgeführt wird, also Vorsicht bzgl. Sicherheitsproblemen!
.TP
.I Option(en)
Die I<Option(en)> werden als Default für eix-sync ausgeführt (vor allen anderen Optionen).
Wie üblich muss I<Option(en)> mit "B<->" beginnen. I<option(en)> wird von der Shell mit "eval" ermittelt:
Daher also Vorsicht bzgl. Sicherheit! Quoten von Shell-Commando-Trennern ist ebenfalls geboten.
.TP
.I Name
Ruft B<layman -s> I<Name> auf
(<layman> ist Teil des Pakets B<app-portage/layman> und dient zum Syncen von Overlays).
.TP
.BR *
Ruft B<layman -S> auf (d.h. alle Overlays werden mit layman gesynct).
.TP
.BI ! Kommando
Ruft eval I<Kommando> innerhalb des B<eix-sync> Shellskripts auf (in der selben Shell).
I<Kommando> muss erfolgreich beendet werden, sonst gibt B<eix-sync> eine Warnung aus.
(Folglich ist B<!layman> I<Name> mehr oder weniger äquivalent zu I<Name>.)
Es ist möglich das Kommando beispielsweise mit "; true" zu beenden, falls der
Exit-Status ignoriert werdne soll.
Mit der Option B<-F> wird aus der Warnung sogar ein fataler Fehler.
Durch Setzen von B<FATAL_HOOKS> auf einen nichtleeren/leeren Wert kann der
Effekt von B<-F> für alle anschließenden Hooks erzwungen/aufgehoben werden.
Falls nur der aktuelle Hook mit einem Fehler beendet werden soll,
kann man explizit B<die> aufrufen.

Man kann dieses Feature benutzen um z.B. einen Overlay vor dem Aufruf von B<layman>
zu entpacken oder um lokale Fixes auszuführen, nachdem B<layman> aufgerufen wurde.

Im Gegensatz zu früheren eix-Versionen gibt, I<Kommando> nichts aus
(mit einfo kann man Ausgabe erreichen), und I<Kommando> wird nicht in einer
Subshell ausgeführt, d.h. man kann auch Environmentvariablen modifizieren
or eine Ausgabeumleitung starten/beenden.
Der Nachtiel ist, dass man auch leicht versehentlich interne eix-sync-Variablen
oder -Funktionen überschreiben kann; im Zweifelsfall ist es daher besser,
dass Kommando in runde Klammern zu packen (...) um es in einer Subshell auszuführen.
.TP
.BI !! Kommando
Die ist ähnlich zu B<!> I<Kommando> mit dem Unterschied, dass
I<Kommando> immer ausgeführt wird, d.h. selbst wenn die
Optionen -d, -u oder -l benutzt wird.
Es ist dazu gedacht, Environmentvariablen für andere Programme zu setzen.
.TP
.BI ~ Kommando
Dies ist nur für die eix-sync-Optionen B<-s> oder B<-2> wichtig.
In diese Fall wird I<Kommando> vor dem ersten Aufruf von B<rsync> ausgeführt;
die Ausgabe von I<Kommando> wird innerhalb der B<eix-sync> Shell mit "eval" ausgeführt.
Falls I<Kommando> oder die das "eval" der Ausgabe nicht erfolgreich sind,
wird B<eix-sync> eine Warnung ausgeben (oder einen Fehler, falls B<-F> aktiv ist,
d.h. wenn B<FATAL_HOOKS> nichtleer ist).
Dies kann benutzt werden um beispielsweise B<keychain> auszuführen oder
den Inhalt einer I<~/.keychain/*-sh>-Datei oder export-Kommandos für die
aktuellen B<SSH_AUTH_SOCK> und B<SSH_AGENT_PID> auszugeben.
Es ist ebenfalls zulässig, dass die Ausgabe von I<Kommando> ein Kommando ist,
das die Variablen B<PORTAGE_RSYNC_OPTS>, B<PORTAGE_RSYNC_EXTRA_OPTS>,
B<PORTDIR>, B<PORTDIR_SERVER>, B<PORTDIR_CLIENT>, B<SERVER> oder B<CLIENT> modifiziert.
Diese variables werden mit ihrem Default gefüllt, wenn I<Kommando> aufgerufen wird
und werden später im B<rsync> Kommando mit ihrer offensichtlichen Bedeutung benutzt.
.TP
.BI @ Kommando
Fügt einen Hook für I<Kommando> hinzu; die tatsächliche Ausführung von I<Kommando>
wird zurückgestellt, bis B<emerge --sync> (erfolgreich) ausgeführt wurde.
.TP
.BI @@ Kommando
Fügt einen Hook für I<Kommando> hinzu; die tatsächliche Ausführung von I<Kommando>
wird zurückgestellt, bis B<emerge --sync> und das darauffolgende B<eix-update> (erfolgreich) ausgeführt wurde.

.TP
Es folgt ein B<schematischer> Überblick über die Reihenfolge der Hooks/Kommandos:

.BR !! " hooks"

.BR "cp @EIX_CACHEFILE@ @EIX_PREVIOUS@"

layman-Aufrufe und B<!>-Hooks in der Reihenfolge von @SYSCONFDIR@/eix-sync.conf

.BR ~ " hooks"

.BR "emerge --sync"

.BR @ " hooks"

.BR "eix-update"

.BR @@ " hooks"

.BR eix-diff

.TP
Einige Beispiele nützlicher Zeilen in B<@SYSCONFDIR@/eix-sync.conf>:
.TP
.B -F
Stets ein Fehlerabbruch, falls layman/hook fehlschlägt.
Dies war bei früheren eix versionen stets der Fall.
.TP
.B -C --ignore-default-opts
Diese Zeile sollte benutzt werden, falls --ask in EMERGE_DEFAULT_OPTS in
/etc/make.conf steht, so dass keine Rückfrage für eix-sync erfolgt.
.TP
.B -r -M
Dies ist nüztlich bei B<PORTDIR_CACHE_METHOD=assign>, falls
B<FEATURES=metadata-transfer> inaktiv oder ausgeschaltet ist
(Letzteres ist bei neueren Portage-Versionen der Fall).
Je nach Bedarf kann auch B<-r> oder B<-M> alleine angegeben werden.
Oder man kann -M durch die Zeile
.TP
.B @emerge --regen
ersetzen, um B<emerge --regen> statt B<emerge --metadata> zu benutzen.
.TP
.B @egencache --repo=local --update
Updated den Metadaten-Caches des Overlays mit dem Repository-Namen "local"
bevor eix-update aufgerufen wird, aber nach dem Aufruf von emerge --sync.
Dies kann bei Benuztung der Cache-Methode B<metadata-flat> für diesen Overlay
sinnvoll sein, falls man sicher sein will, dass der Metadaten-Cache aktuell ist.
Der Nachteil ist, dass dieses B<egencache>-Kommando auch dann ausgeführt wird,
wenn "local" nicht verändert wurde (was für locale Repositories typisch ist).
.TP
.B !egencache --repo=foo --update
Updated den Metadaten-Cache des Overlays mit Repository-Namen "foo";
dies kann sinnvoll sein, falls vorher eine Zeile B<foo> oder eine Zeile B<!Kommando zum Updaten von foo> steht,
um diese Repository (durch layman oder ein anderes Kommando) zu updaten,
und falls die Cache-Methode B<metadata-flat> für diesen Overlay benutzt werden soll,
obwohl der Metadaten-Cache kaputt oder nicht im Repository enthalten ist.
.TP
.B !!exec >/var/log/eix-sync.log ; chown portage: /var/log/eix-sync.log || true
Sendet die Ausgabe in eine log-Datei (mit korrekten Rechten).
Das "true" am Ende sorgt für Weiterausführung selbst wenn "chown" fehlschlägt.
Falls die Ausgabe des abschließenden B<eix-diff> nicht umgeleitet werden soll,
kann man dies kombinieren mit
.TP
.B @@exec >/dev/tty
Ausgabe von B<eix-diff> auf das Terminal, selbst im Falle von Ausgabeumleitung.
.TP
.B @@exit 0
Keine Ausführung des abschließenden B<eix-diff>.
.TP
.B !!export FORCE_USECOLORS="${FORCE_USECOLORS:-true}"
Falls FORCE_USECOLORS nicht in der Environment anders gesetzt wurde,
wird die eix-Ausgabe auch im Falle von Ausgabeumleitung farbig.
.TP
.B ~keychain --quiet ~/.ssh/id_rsa ; cat ~/.keychain/"`hostname`-sh"
.TP
.B @@eix-remote update
.TP
.B @eix-remote fetch
.TP
.B @@eix-remote add
.\" }}}

.\" {{{ -------- @SYSCONFDIR@/eixrc
.SS @SYSCONFDIR@/eixrc
Globale Konfigurations-Datei.
Die variablen in B<~/.eixrc> oder von der Environment können
die Variablen aus dieser Datei überschreiben, siehe B<~/.eixrc>.
.\" }}}

.\" {{{ -------- EIXRC
.SS EIXRC
Wenn diese Environmentvariable gesetzt ist, wird ihr Wert anstelle des Dateinamen
@SYSCONFDIR@/eixrc benutzt, um die Konfigurationsdaten zu lesen.
In diesem Fall wird die Datei ~/.eixrc ignoriert
(aber sie kann natürlich ggf. gesourced werden).

.SS EIX_SYNC_OPTS, EIX_SYNC_CONF, EIX_REMOTE_OPTS, EIX_LAYMAN_OPTS, EIX_TEST_OBSOLETE_OPTS
Obwohl diese Variablen typischerweise in ~/.eixrc gesetzt werden
(und daher erst im nächsten Abschnitt beschrieben werden),
werden diese Variablen hier hervogehoben, weil sie besonders sicherheitsrelevant sind:
Sie (oder zumindest Teile von ihnen) werden durch die Shell ausgeführt, wenn die
enstprechenden Skripte ausgeführt werden.
Daher sollte man sicher gehen, dass diese Variablen nicht kompromittiert sind, wenn diese Skripte mit root-Rechten ausgeführt werden.
.\" }}}

.\" {{{ -------- ~/.eixrc
.SS ~/.eixrc
User-spezifische Konfigurations-Datei.
Die Variablen dieser Datei können durch Environmentvariablen überschrieben werden.
In dieser Datei kann eine Shell-ähnliche Syntax benutzt werden, um die folgenden Variablen zu setzen.
Insbesondere können andere Dateien gesourced werden und Hilfsvariablen benutzt werden
um andere Variablen zu setzen.

Dabei ist jedoch zu beachten, dass bei der überlichen Benutzung von Hilfsvariablen
nur die Ergebnisse bei --dump oder --dump-defaults angezeigt werden,
und man kann die eingesetzten Werte nicht durch Environmentvariablen abändern.

Aus diesem Grund gibt es neben der Shell-üblichen Derefenzierung von Variablen
auch eine weitere Möglichkeit der Dereferenzierung mit der
Syntax B<%{>I<VARIABLE>B<}> (the Klammern hier sind nicht-optional).
Diese Syntax bedeutet, dass die Ersetzung so lange verzögert wird, bis
alle Konfigurationsdateien und Environmentvariablen gelesen werden,
und die Ersetzung wird bei --dump oder --dump-defaults nicht durchgeführt.

Dieses Konzept wird verzögerte Ersetzung/Referenz genannt, und es
bietet einige zusätzliche Features:

.\" {{{ -------- Spezielle Symbole
.TP
.B Specielle Symbole zur verzögerten Ersetzung
.RS

.TP
.B " %{%"
Dies muss benutzt werden, falls B<%{> im Variablentext stehen soll
(sonst würde verzögerte Ersetzung aktiv).

.TP
.BI * VARIABLE
Falls die verzögerte Referenz eine Variablennamen benutzt, der mit B<*> beginnt,
so wird dieses B<*> durch B<EIX_>, B<DIFF_>, B<UPDATE_> oder B<DROP_> ersetzt,
je nachdem ob es von B<eix>/B<eix-diff>/B<eix-diff> bzw. B<eix-drop-permissions> benutzt wird.
Auf diese Weise kann man verschiedene Defaults für diese Programme festlegen.

Beispielsweise wird die verzögerte Referenz B<%{*>I<VARIABLE>B<}> die Expansion
der Variablen B<EIX_>I<VARIABLE>, B<DIFF_>I<VARIABLE>, B<UPDATE_>I<VARIABLE>
bzw. B<DROP_VARIABLE> einfügen.

Die B<\\>- und B<*>-Attribute können kombiniert werden (die Reihenfolge spielt keine Rolle).

Ein praktisches Beispiel: Falls B<EIX_USER> den Wert "nobody" haben soll,
falls es von B<eix-drop-permissions> (also etwa durch B<eix-remote>)
aufgerufen wird, aber den Default-Wert "portage" in allen anderen Fällen,
kann man folgendes Setzen:

.B EIX_USER="%{*EIX_USER}"

.B EIX_EIX_USER="portage"

.B DIFF_EIX_USER="portage"

.B UPDATE_EIX_USER="portage"

.B DROP_EIX_USER="nobody"

.TP
B<\\>I<VARIABLE>
Falls eine verzögerte Referenz einen Variablennamen benutzt, der mit B<\\> beginnt,
so werden alle \\ or [\\n\\r\\t ] Zeichen des (expandierten) Inhalts von
I<VARIABLE> als escaped betrachtet.

Insbesondere kann die verzögerte Referenz B<%{\\>I<VARIABLE>B<}> in
Stiring-List-Variablen wie B<CACHE_METHOD> oder B<EIX_LOCAL_SETS> benutzt werden
und stellt dabei sicher, dass I<VARIABLE> höchstens einen Eintrag "so wie er ist"
erzeugt, selbst dann, wenn dieser Eintrag Leerzeichen oder des Zeichen \\ enthält.

Die B<\\>- und B<*>-Attribute können kombiniert werden (die Reihenfolge spielt keine Rolle).
.RE
.\" }}}

.\" {{{ -------- Konditionelle Blocks in verögerten Referenzen
.TP
.B Konditionelle Blocks in verögerten Referenzen
Falls einige Variableninhalte in Abhängigkeit einer (Booleschen) Variablen
ganz anders aussehen sollen, können konditionelle Blocks benutzt werden.

Dies ist analog zu konditionellen Blocks im FORMATSTRING:
Wenn die referenzierte Variable schließlich zum Booleschen Wert "true"
expandiert (B<true>/B<1>/B<yes>/B<y>/B<on>) (bzw. zu etwas Nichtleerem,
falls I<VARIABLE> ein zusätzliches B<?> vorangestellt wird), so ist
das Ergebnis wahr, und der entsprechende Block des Strings wird expandiert.
Konditionen können negiert werden, so dass  der else-Teil expandiert wird,
wenn die Bedingung wahr ist und der if-Teil, wenn die Bedingung falsch ist.
Der else-Teil kann auch vollständig weggelassen werden.
Die speziellen Variablennamen B<*>I<VARIABLE> (statt I<VARIABLE>)
können auch hier benutzt werden.

.RS
.TP
.BI %{? VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu "true" expandiert.

.TP
.BI %{?? VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem nichtleeren String expandiert.

.TP
.BI %{! VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> nicht zu "true" expandiert.

.TP
.BI %{!? VARIABLE } TCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem leeren String expandiert.

.TP
.BI %{? VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE> falls I<VARIABLE> zu "true" expandiert, sonst zu I<FCODE>.

.TP
.BI %{?? VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem nichtleeren String expandiert, sonst zu I<FCODE>.

.TP
.BI %{! VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> nicht zu "true" expandiert, sonst zu I<FCODE>.

.TP
.BI %{!? VARIABLE } TCODE %{else} FCODE %{}
Expandiert zu I<TCODE>, falls I<VARIABLE> zu einem leeren String exapndiert, sonst zu I<FCODE>.

Ein konditioneller Block muss vollständig in einer einzigen Variable stehen,
d.h. es ist nicht möglich, beispielsweise das B<%{}> Zeichen aus einer anderen Variable
über verzögerte Ersetzung zu erhalten (aber in I<TCODE>/I<FCODE> können wiederum
verzögerte Referenzen enthalten sein).
.RE
.\" }}}

Beachten Sie, dass Variablen, die zu verzögerten Ersetzung benutzt werden nur dann
mit --dump ausgegeben werden, wenn sie tatsächlich benutzt werden (d.h. in einer anderen
Variable dereferenziert werden).
Falls sietrotzdem ausgegeben werden sollen, etwa für Kommentare oder leichtere spätere Änderungen,
so können Referenzen auf sie in der B<DUMMY>-Variable gespeichert werden.

Die folgenden Variablenliste enthält nicht die Variablen, die in verspäteter Ersetzung benutzt werden.
Um eine Beschreibung der Letzteren (und ihrer Defaults) zu erhalten, benutzen Sie bitte B<eix --dump>.
.TP
.B DUMMY " " (string)
Diese Variable hat keinen direkten Einfluss auf das Programm, aber ihr Inhalt
kann benutzt werden, um verzögerte Ersetzungen zu (ansonsten unbenutzten) Variablen
zu sammeln, so dass diese mit --dump oder --dump-defaults ausgegeben werden.

.TP
.BR EIX_SYNC_OPTS ", " EIX_SYNC_CONF " " (string)
Der Inhalt von B<EIX_SYNC_CONF> wird an die Datei B<@SYSCONFDIR/eix-sync.conf> angehängt.
Weitere Details finden sich in der Beschreibung jener Datei.
Per default ist B<EIX_SYNC_CONF> eine verzögerte Ersetzung von B<EIX_SYNC_OPTS>,
so dass typischerweise B<EIX_SYNC_OPTS> zum gleichen Zweck genutzt werden kann.
Vorsicht: Wenn eine dieser Variablen kompromittiert ist, kann beim Aufruf von
B<eix-sync> mit Root-Rechten nahezu alles passieren!
Diese Variablen müssen im Falle einer Benutzung vorsichtig gequotet werden.

.TP
.BR EIX_REMOTE_OPTS ", " EIX_LAYMAN_OPTS ", " EIX_TEST_OBSOLETE_OPTS " " (string)
Der Inhalt dieser Variablen wird einem "eval" unterzogen und als Argumente für die Skripte
B<eix-remote>, B<eix-layman> bzw. B<eix-test-obsolete> benutzt.
Diese Variablen sind also vorsichtig zu quoten. Vorsicht vor Sicherheitsrisiken!

.TP
.BR EIXRC_SOURCE " " (string)
Dieser Pfad wird bei Source-Kommandos in @SYSCONFDIR@/eixrc vorangestellt.
Er ist gedacht, in der Environment gesetzt zu werden, aber er kann auch in @SYSCONFDIR@/eixrc gesetzt werden.
Im letzte Fall wird er alle Settings aus der Environment überschreiben, sobald er gelesen wird,
so lange bis alle Dateien gesourced wurden.
Beachten Sie, dass noch keine verzögerte Ersetzung stattfindet, wenn diese Variable aktiv wird.

.TP
.BR EIX_PREFIX " " (prefix-string) " (prefix-string heißt, dass dies ein String ist, aber wenn es den Wert '/' hat, wird dieser geändert zu '')"

Dies ist i.W. dazu gedacht in der Environment gesetzt zu werden, falls eine chroot benutzt wird:
Es wird dem Pfad vorangestellt, in dem @SYSCONFDIR@/eixrc gesucht wird.
Falls es nicht gesetzt ist, wird der Wert der Environment-Variable B<PORTAGE_CONFIGROOT> vorangestellt.
Der Default-Wert (typischerweise leer) dieser Variable wird benutzt, falls keines
von beiden in der Environment gesetzt ist.

Darüberhinaus wird dieser Variable in der verzögerten Ersetzung benutzt,
um den Präfix einer Menge von Pfaden der folgenden Variablen zu setzen;
mit B<eix --dump> erfährt man im Detail, in welchen anderen Variablen sie vorkommt.

.TP
.BR EPREFIX " " (prefix-string)
Der Defaultwert dieser Variable kommt von EIX_PREFIX, wobei ein
configure-spezifischer Default (für prefix-portage) angehängt wird.
Diese Variable hat alleine keine Bedeutung, aber sie wird
mit verzögerte Ersetzung benutzt, um den Präfix einer Reihe von Pfaden
in den folgen Variablen festzulegen (wenn ihr Default nicht geändert wird);
mit B<eix --dump> erfährt man im Detail, in welchen anderen Variablen sie vorkommt.
Im derzeitigne Default beeinflusst sie alle Pfade mit den folgenden Ausnahmen:

.RS
.RS

.B @BINDIR@/eix-functions.sh

.B ~/.eixrc

.BR "Cachedateipfad" "(e) aus der Kommandozeile"

.BR PORTAGE_PROFILE " (nur die variable, nicht der Link)"

.B PORTDIR

.B Overlay-Pfade
.RE

Die letzten drei Punkte können durch B<EPREFIX_TREE> modifiziert werden.

Der Zweck von B<EPREFIX> ist es, eine quasi-chroot analog zu prefix-portage zu erlauben.
.RS

.BR ROOT " " (prefix-string)

.BR EPREFIX_TREE " " (prefix-string)

.BR EPREFIX_ROOT " " (prefix-string)
.RE

Dies sind tatsächlich nicht interne Variablen von eix, sondern sie werden nur
zur verzögerten Ersetzung für die folgenden Variablen analog zu B<EPREFIX> benutzt (siehe oben).

Der Zweck von B<ROOT> ist es, ungefähr Portage's Nutzung dieser Variablen wiederzuspiegeln.
Beachte, dass die Variablen in /etc/make.conf keinen Einfluss auf eixs Konfigurationsvariablen haben.
Insbesondere wird ein Kommando B<ROOT=>I<something> in /etc/make.conf keinen Einfluss auf eix haben.
Es muss statt dessen in der Environment oder eine Konfigurationsdatei von eix gesetzt werden.

Man kann leicht konfigurieren, auf welche Pfade die Variablen B<EPREFIX> oder B<ROOT> Einfluss nehmen:
Man muss in den entsprechenden folgenden Variablen nurr entsprechend die verzögerte Referenz
B<%{EPREFIX}>, B<%{ROOT}>, nichts, oder B<%{EPREFIX_ROOT}> benutzen.
(Letzteres ist seinerseits als verzögerte Referenz definiert ist, so dass
man leicht ändern kann was geschehen soll, falls B<EPREFIX> und B<ROOT> beide
nichtleer sind: Man kann sie aneinandersetzen oder nur eines davon benutzen).
Man kann natürlich auch andere Variablen zur verzögerte Ersetzung benutzen;
beispielsweise könnte man

.B EIX_CACHEFILE="%{EPREFIX_PROFILE}@EIX_CACHEFILE@"

setzen, wenn man will, dass die Cachedatei von eix (nur) vom PROFILE-Wurzelverzeichnis abhängen soll.
.RE

.TP
.BR PORTAGE_CONFIGROOT " " (prefix-string)
Dieser Pfad wir /etc-Pfaden vorangestellt.
Der Zweck ist es, PORTAGE_CONFIGROOT auf analoge Weise wie portage zu berücksichtigen.
Falls diese Variable in der Environment gesetzt wird, wird sie auch den Pfad ändern,
in dem @SYSCONFDIR@/eixrc gesucht wird.
(Beachte, dass das Lesen von @SYSCONFDIR@/eixrc geschieht, bevor verzögerte Ersetzung aktiv wird.)

.TP
.BR MAKE_GLOBALS " " (string)
Falls diese Datei existiert, so wird sie anstelle von
B<%{PORTAGE_CONFIGROOT}/etc/make.globals>
benutzt.
Der Defaultwert entspricht dem Verhalten von >=portage-2.2*

.TP
.BR EPREFIX_SOURCE " " (prefix-string)
Dies Pfad wird allen Pfaden vorangestellt, die als Argumente von Source-Kommandos
in /etc/make.conf und /etc/make.globals auftauchen.

.TP
.BR EPREFIX_INSTALLED " " (prefix-string)
Die wird allen Pfaden vorangestellen, in den eix Informationen über installierte Pakete sucht.

.TP
.BR EPREFIX_PORTAGE_CACHE " " (prefix-string)
Dieser Präfix wird dem Portage Cache vorangestellt.

.TP
.BR EPREFIX_ACCESS_OVERLAYS " " (prefix-string)
Dieser Präfix wird Overlays vorangestellt, sobald auf ihre Dateien zugegriffen wird.

.TP
.BR EPREFIX_PORTDIR " " (prefix-string)
Dieser Pfad wird B<PORTDIR> vorangestellt.

.TP
.BR EPREFIX_OVERLAYS " " (prefix-string)
Dieser Präfix wird allen Einträgen von B<PORTAGE_OVERLAY> vorangestellt.

.TP
.BR EPREFIX_PROFILE " " (prefix-string)
Dieser Präfix wird B<PORTAGE_PROFILE> (die Variable, nicht der Link) vorangestellt.

.TP
.BR EPREFIX_VIRTUAL " " (prefix-string)
Dies wir Overlays in der eix Datenbank bei Tests, ob sie existieren, vorangestellt.

.TP
.BR EIX_CACHEFILE " " (string)
Die eix-Cachedatei, normalerweise B<%{EPREFIX}@EIX_CACHEFILE@>

.TP
.BR EIX_PREVIOUS " " (string)
Die alte eix-Cachedatei für eix-diff und eix-sync,
normalerweise B<%{EPREFIX}@EIX_PREVIOUS@>

.TP
.BR EIX_REMOTEARCHIVE " " (string)
Eine lokale Kopie des Remote-Archivs, auf das eix-remote zugreift.
Falls es leer ist, werden nur Temporärdateien benutzt.

.TP
.BR EIX_WORLD " " (string)
Die Datei, die eix als world-Datei betrachtet.
Beachte, dass diese Datei normalerweise nur für Mitglieder der Gruppe portage lesbar ist.
Um diese Privilegien zu vermeiden, kann B<SAVE_WORLD> benutzt werden.

.TP
.BR EIX_WORLD_SETS " " (string)
Die Datei, die eix als world_sets benutzt.
Es gilt dasselbe wie für B<EIX_WORLD>

.TP
.BR EIX_LOCAL_SETS " " "(Stringliste)" "(die Bedeutung von Stringliste wird im nächsten Absatz erklärt)"
Dies ist eine Liste von Verzeichnissen, die lokal definierte Sets enthalten.
Die Verzeichnisse werden in der gegebenen Ordnung gelesen;
Dateien mit Setnamen, die früher gelesen wurden, werden ignoriert:
In diesem Sinne haben frühere Einträge inB<EIX_LOCAL_SETS> eine höhere Präzedenz.

Relative Verzeichnisse (d.h. solche, die nicht mit B</> beginnen) werden relativ zu B<$PORTDIR> aufgefasst.
Einträge in B<EIX_LOCAL_SETS>, die mit dem speziellen Zeichen B<*> beginnen, werden auf spezielle Art interpretiert:
Sie werden als mehrere Einträge interpretiert, wobei das B<*>-Zeichen die
Pfade zu den Overlays in umgekehrter Ordnung durchläuft
(umgekehrte Ordnung deswegen, weil in gewissem Sinne frühere Einträge
in B<EIX_LOCAL_SETS> spätere überschreiben, während man für B<PORTDIR_OVERLAY>
das Umgekehrte erwartet).

Der Default dieser Variable enthält B</etc/portage/sets>, B</etc/portage/sets.eix>, B<sets>
(d.h. ungefähr B<${PORTDIR}/sets> nach dem vorherigen Absatz),
B<*/sets> (d.h. ungefähr B<${PORTIDR_OVERLAY}/sets> nach dem vorherigen Absatz)
sowie B<%{EIX_LOCAL_SETS_ADD}>.
Der Grund für Letzteres ist, dass man einfach zusätzliche Verzeichnisse
zur Variablen B<%{EIX_LOCAL_SETS_ADD}> in B<@SYSCONFDIR@/eixrc> hinzufügen kann.
Gründe dafür sind beispielsweise, wenn man in /etc/portage/sets.conf oder in der sets.conf Datei eines Overlays
ein weiteres multiset-Verzeichnis definiert,
z.B. für einen Overlay oder für die Behandlung mit "world-candidate = False".

Für alle Stringlisten-Variablen sind die erlaubten Trenner zwischen verschiedenen Einträgen [ \\t\\r\\n].
Falls solch ein Trenner innerhalb eines Eintrags benutzt werden soll, so kann man ihn durch Voranstellen von B<\\> escapen.
Natürlich müssen alle B<\\>-Zeichen analog escaped werden, weil Escapes von Escapes oder Trennzeichen entfernt werden.
Falls eine Variable so, wie sie ist, als einzelner Eintrag eingefügt werden soll, kann man verzögerte Ersetzung benutzen:
B<%{\\>I<VAR>B<}> wird den Wert der Variablen I<VAR> einfügen, wobei alle Zeichen aus [\\ \\t\\r\\n] escaped werden
(mehr Details stehen im Abschnitt zur verzögerten Ersetzung).

.TP
.BR EAPI_REGEX
Dieser reguläre Ausdruck soll auf bekannte EAPIs in .ebuild-Namensanhängen haben,
die gemäß GLEP 55 bekannt sein sollen.
Es kann notwendig sein, diesen Ausdruck lokal entsprechend der installierten Portage-Version zu modifizieren
(um sicherzugehen, dass die installierte Portage-Version die entsprechenden EAPIs parsen kann).
Ein Ausnahmefall ist, wenn diese Variable leer ist:
In diesm Fall werden alle ebuilds mit EAPI-Anhängen ignoriert.

.TP
.BR SAVE_WORLD " " (true / false)
Falls dies gesetzt ist, werden die Informationen der world-Datei in @EIX_CACHEFILE@ gespeichert.
Vorsicht:
Dies bedeutet, dass jeder, der diese Datei lesen kann auch Informationen über die world-Datei hat!

.TP
.BR CURRENT_WORLD " " (true / false)
Falls diese Variable falsch ist, wird die Information über die world-Datei aus @EIX_CACHEFILE@ benutzt,
selbst dann, wenn die aktuelle world-Datei lesbar sein sollte.
Andernfalls wird die aktuelle world-Datei (wenn sie lesbar ist), diese Information überschreiben.

.TP
.BR EIX_USER ", " EIX_GROUP ", " EIX_UID ", " EIX_GID
B<eix>, B<eix-diff>, B<eix-update>, B<eix-drop-permissions> und B<eix-remote>
ändern so früh wie möglich ihre Rechte zu B<EIX_USER>/B<EIX_GROUP>
(bzw. zu den ID-Zahlen B<EIX_UID>/B<EIX_GID>, falls die vorherigen Variablen
keinen gültigen Namen enthalten).
Um dies zu verhinden, kann ein ungültiger Namen (etwa der leere Name) und
eine nicht-positive ID-NUmmer benutzt werden.

Falls B<EIX_GROUP> gültig und B<EIX_GID> positiv ist, dann wird auch die
Gruppenlist nach der folgenden Regel geändert:
Falls B<EIX_USER> ein gültiger Name ist, wird die volle Gruppenliste
dieses Benutzers gewählt; andernfalls schrumpft die Gruppenliste auf
einen einzelnen Eintrag zusammen.

.TP
.BR PORTAGE_ROOTPATH ", " PORTAGE_BIN_PATH
Falls nichtleer, werden diese Variablen unverändert an ebuild.sh für die Cache-Methode B<ebuild*> übergeben.
Beachte, dass ebuild.sh diese Variablen benutzt, um den PATH zu ermitteln, so dass diese
Werte extrem sicherheitsrelevant sind!

.TP
.BR NOFOUND_STATUS " " (integer)
Dieser Wert wird als Exit-Status benutzt, falls kein Paket passt.
Der Wert von B<COUNT_ONLY_PRINTED> wird dabei berücksichtigt.

.TP
.BR MOREFOUND_STATUS " " (integer)
Dieser Wert wird als Exit-Status für 2 oder mehr Treffer benutzt.
Der Wert von B<COUNT_ONLY_PRINTED> wird dabei berücksichtigt.

.TP
.BR QUICKMODE " " (true / false)
Bestimmt, ob für eix und eix-diff die Option B<--quick> der Default ist.

.TP
.BR CAREMODE " " (true / false)
Bestimmt, ob für eix und eix-diff die Option B<--care> der Default ist.

.TP
.BR USE_BUILD_TIME " " (true / false)
Whether to use the BUILD_TIME entry (if it exists) of the portage database
instead of the Verzeichnis timestamp (which usually is the installation time).
The difference is usually only important for packages installed from .tbz2,
but in most cases the build time is more relevant (it is also more reliable).
Unfortunately, the build time is available only for packages built and emerged
with >=portage-2.2_rc63; you can use B<eix-installed [no-]buildtime> to check
for which versions this is (not) the case.
Reading the build time is always slower than using the Verzeichnis timestamp
(even if the build time is not available).
Thus, you might want to set this variable to B<false> if speed of eix is
more important to you than the buildtime information.

.TP
.BR QUIETMODE " " (true / false)
If true, eix and eix-diff will use B<--quiet> by default.

.TP
.BR PRINT_APPEND " " (string)
This string is appended to the output of --print.
Standard escape sequences in this string like \\n are interpreted.
The default is a newline for reasonable output in an interactive shell.
Note that command substitution in shell scripts removes all trailing spaces
so that this newline does not harm (but trailing spaces of the variable would
be removed in the shell script anyway).
Hence, in order to read variables from eix in a shell script without omitting
trailing spaces, you should use a visible symbol for PRINT_APPEND and use
for instance something like
B<VAR="`PRINT_APPEND=x eix --print VAR`" ; VAR="${VAR%x}">

.TP
.BR NEWLINE " " (true / false)
If true, eix will print a newline after each version for which the formatstring outputs something.
You will find B<true> convenient if you use trivial formatstrings which output only one line
(unless you want to add the newline manually to the formatstring).
However, if you use a formatstring which outputs versions in separate lines,
and only those versions are output for which certain tests succeed,
it might be rather cumbersome to keep track in the formatstring whether you must output a newline or
whether this will happen automatically.
In such cases you should should avoid the headache and put B<NEWLINE=false>.
The default formatstrings of eix produce correct output for both settings
(by checking the value of B<NEWLINE> and outputting the newline only if it is required).

Unless you need to support formatstring which you had previously written,
I recommend to leave the default B<NEWLINE=false> and to add manually a B<\\n>
(or an explicit newline) at the end of your formatstring.
Moreover, if you had written formatstrings, I recommend to upgrade them to
output this newline instead of setting B<NEWLINE=true>; this option really
just exists for backward compatibility and might be removed in future versions
of eix.

.TP
.BR DEFAULT_FORMAT " " (normal / compact / verbose)
Defines whether B<--compact> or B<--verbose> is on by default.

.TP
.BR DIFF_ONLY_INSTALLED " " (true / false)
If true, eix-diff will only consider version changes for installed packages.

.TP
.BR DIFF_NO_SLOTS " " (true / false)
If true, eix-diff will not consider slots for version changes.

.TP
.BR DIFF_SEPARATE_DELETED " " (true / false)
If true, eix-diff will print deleted packages in a section on their own.
Otherwise, eix-diff will mix deleted and changed packages "alphabetically".

.TP
.BR DIFF_PRINT_HEADER " " (true / false)
If true, eix-diff will print a header info line.

.TP
.BR NO_RESTRICTIONS " " (true / false)
If false, RESTRICTION and PROPERTIES data is output.

.TP
.BR RESTRICT_INSTALLED " " (true / false)
If true, fetch and mirror restrictions for installed versions are calculated.

.TP
.BR CARE_RESTRICT_INSTALLED " " (true / false)
If true, fetch and mirror restrictions for installed versions are
always fetched from disk, even if it could be read from a corresponding version.
This is slower but more reliable, i.e. it will also find out whether restrictions were changed.

.TP
.BR DEP " " (true / false)
If true, store/use B<DEPEND>, B<RDEPEND>, B<PDEPEND> (e.g. shown with eix -lv).
Usage of B<DEP> roughly doubles disk resp. memory requirements.

.TP
.BR FORMAT ", " FORMAT_COMPACT ", " FORMAT_VERBOSE " " (string)
Define the normal, compact and verbose layout for results printed by B<eix>.
See B<FORMATSTRING>.
Since eix-0.13.4 these variables just expand to delayed substitution of the
variables B<FORMAT_ALL>, B<FORMAT_ALL_COMPACT>, or B<FORMAT_ALL_VERBOSE>,
respectively.
The intention of this simple definition is that it is very easy to refer
to the default definition when you change the definition of B<FORMAT>.

.TP
.BR DIFF_FORMAT_NEW ", " DIFF_FORMAT_DELETE ", " DIFF_FORMAT_CHANGED " " (string)
Define the format for packages that were added, removed or for which the highest
stable versions has changed. This is only used by B<eix-diff>.
See B<FORMATSTRING>.
Since eix-0.13.4 these variables just expand to delayed substitution of the
variables B<DIFF_FORMAT_ALL_NEW>, B<DIFF_FORMAT_ALL_DELETE>, or
B<DIFF_FORMAT_ALL_CHANGED>, respectively.

.TP
.BR FORMAT_INSTALLATION_DATE ", " FORMAT_SHORT_INSTALLATION_DATE
Define the strftime() format used to print the installation date (in normal resp. short form).

.TP
.BR FORMAT_INSTALLED_USE
Define the printf-like format used to print useflags of installed packages.
If this string is empty, the processing is slightly faster since then these data are not read.

.TP
.BR FORMAT_BEFORE_SET_USE ", " FORMAT_AFTER_SET_USE ", " FORMAT_BEFORE_UNSET_USE ", " FORMAT_AFTER_UNSET_USE
These strings are printed before/after the set/unset USE flags of installed versions are printed.

.TP
.BR NOCOLORS " " (true / false)
Do not use colors.

.TP
.BR NOSTATUSLINE " " (true / false)
Do not update status line.

.TP
.BR NOPERCENTAGE " " (true / false)
Do not show percentage progress.

.TP
.BR FORCE_COLORS " " (true / false)
Use colors even when stdout is not a terminal.

.TP
.BR FORCE_STATUSLINE " " (true / false)
Update the status line even when stdout is not a terminal.

.TP
.BR FORCE_PERCENTAGE " " (true / false)
Show the percentage progress even when stdout is not a terminal.

.TP
.BR STYLE_VERSION_SORTED " " (true / false)
Defines whether B<--versionsort> is on by default.

.TP
.BR STYLE_VERSION_LINES " " (true / false)
Defines whether B<--versionlines> is on by default.

.TP
.BR DUP_PACKAGES_ONLY_OVERLAYS " " (true / false)
Defines whether duplicate package checks occur only among overlays, i.e. a
package is only considered as duplicate if it occurs in at least two
different overlays.

.TP
.BR DUP_VERSIONS_ONLY_OVERLAYS " " (true / false)
Defines whether duplicate version checks occur only among overlays, i.e. a
version is only considered as duplicate if it occurs at least twice in
overlays.

.TP
.BR DEFAULT_IS_OR " " (true / false)
If several pattern arguments occur without logical concatenation (-a or -o),
eix assumes an implicit concatenation. If this variable is true, it assumes
that this concatenation is -o (or), otherwise -a (and).

.TP
.BR OVERLAYS_LIST " " (all / all-if-used / all-used / all-used-renumbered / no)
People with many different overlays do not want to see all overlays listed at
the end but only those which are really used. Here, you can customize the
behaviour. The value is interpreted as follows:

.RS
.TP
.BR all-if-used / if-used / if
Display all overlays, if at least one is used. This was the default behaviour
before eix-0.6.0.
.TP
.BR used-renumbered / renumber / renumbered / number
Display only the overlays actually used, numbering them "correctly"
(i.e. if only two overlays are needed, number them [1] and [2]).
The disadvantage is that overlays get different numbers for different queries.
However, the order of the numbering is consistent.
.TP
.BR all-used / only-used / used
Display only the overlays actually used, keeping the numbering consistent
over all queries (on the same database).
.TP
.BR no / false
Never display a list of overlays.
.TP
anything else
List all overlays for every query (even if not even one is needed).
.RE

.TP
.BR TERM " " (string)
The current terminal. Usually this is set by the environment variable.

.TP
.BR TERM_STATUSLINE " " (string)
This is a list of (space-separated) words; if one of these words matches
the beginning of TERM, it is assumed that the terminal supports a status line.

.TP
.BR TERM_SOFTSTATUSLINE " " (string)
This is a list of (space-separated) words; if one of these words matches
the beginning of TERM, and if the statusline is active, also a soft status line
(used e.g. by screen but not by tmux) will be output.

.TP
.BR EXIT_STATUSLINE " " (string)
If this is nonempty, it is used as the exit statusline.
An optional leading space in this string is ignored.

.TP
.BR LEVENSHTEIN_DISTANCE " " (integer)
Set default levenshtein-distance.

.TP
.BR UPDATE_VERBOSE " " (bool)
Whether eix-update -v is on by default (output of cache method per version).

.TP
.BR EXCLUDE_OVERLAY " " "(Stringliste)"
Set a list of wildcard patterns for overlay paths that are excluded from the index.
See the B<eix-update> option B<--exclude-overlay>.

.TP
.BR ADD_OVERLAY " " "(Stringliste)"
Set a list of overlays that are added to the index.
See the B<eix-update> option B<--add-overlay>.

.TP
.BR EXPORT_PORTDIR_OVERLAY " " (true / false)
If true and overlays are excluded/added, a correspondingly modified
B<PORTDIR_OVERLAY> is exported.
This means that in a sense also the corresponding eclasses of these overlay
are excluded/added for cache methods eix and eix*.

.TP
.BR CACHE_METHOD_PARSE " " (string)
This string is appended to all cache methods using parse/parse*/ebuild/ebuild*.
Its default contains B<#metadata-md5#metadata-flat>.
Unless you have a very special setup this is always what you want:
It means that if a current metadata (in a metadata/*cache Unterverzeichnis)
is available for the ebuild,
this is used instead of parsing/executing the ebuild.
The latter is in principle not completely reliable (parsing) or
rather slow (executing), i.e. the metadata
(if available and up-to-date) is always preferable.

.TP
.BR PORTDIR_CACHE_METHOD ", " OVERLAY_CACHE_METHOD " " (string)
Set the type of the cache used by portage and for overlays.
B<PORTDIR_CACHE_METHOD> defaults to I<@PORTDIR_CACHE_METHOD@>,
B<OVERLAY_CACHE_METHOD> to I<parse|ebuild*>.

B<Security Warning:>
If you do not completely trust the .ebuilds in your overlays,
you should set B<OVERLAY_CACHE_METHOD=parse>.

You might want to set temporarily B<OVERLAY_CACHE_METHOD=eix*::~> -
as will be explained later, eix will then take by default the overlay data
from the previous eix database.

The available cache methods are described below.
You might want to specify a different cache method only for some overlays.
This can be done with the following variables:

.TP
.BR CACHE_METHOD ", " OVERRIDE_CACHE_METHOD " " "(Stringliste)"
These variables are Stringlistes of the form "I<overlay> I<method> I<overlay> I<method> ...".
The cache method of I<overlay> is set to the subsequent I<method>,
thus overriding the default settings of B<OVERLAY_CACHE_METHOD>
(or of B<PORTDIR_CACHE_METHOD> if I<overlay> is the B<PORTDIR> Verzeichnis).
I<overlay> is interpreted as a wildcard pattern which should match the I<path> (symbolic links resolved) of the overlay
(it is not possible to refer to repository's name here - you must use the true I<path>).
Later entries override earlier ones: The last matching entry takes precedence.

.RS
The difference between B<CACHE_METHOD> and B<OVERRIDE_CACHE_METHOD> is that
the former applies immediately while the latter can also be used to
extend/override the changes made implicitly if B<KEEP_VIRTUALS> is used
(see below).

The default definitions of B<CACHE_METHOD> and B<OVERRIDE_CACHE_METHOD>
contain B<%{ADD_CACHE_METHOD}> and B<%{ADD_OVERRIDE_CACHE_METHOD}>, respectively.
According to the mechanism of delayed substitution explained in another section,
this means that the variables B<ADD_CACHE_METHOD> or
B<ADD_OVERRIDE_CACHE_METHOD> can also be used to override the cache method locally.
If you modify B<CACHE_METHOD> or B<OVERRIDE_CACHE_METHOD> in B<@SYSCONFDIR@/eixrc>,
it is recommended to add " B<%{ADD_CACHE_METHOD}>" or
" B<%{ADD_OVERRIDE_CACHE_METHOD}>" (note the space in front of B<%>)
at the end of the respective modified definitions, so that these variables
can still be used for local overriding.

The following cache methods are available:

.TP
.BR metadata-flat " or " metadata-flat:I<PATH>
Use the metadata-cache located inside the portage-tree ($PORTDIR/metadata/cache).
.RS
If you provide I<PATH>, it overrides the above path; in this case, it must be
the full path (i.e. no prefix is used). You might want to provide I<PATH> if
you use some package manager to generate the metadata in the corresponding
Verzeichnis.
.RE
.TP
.BR metadata-md5 " or " metadata-md5:I<PATH>
This is similar to B<metadata-flat> with the difference that the Dateis within
($PORTDIR/metadata/md5-cache) are used where an md5sum is used instead of the
timestamp to check whether the metadata is up-to-date.
This should be the preferred method for overlays if the overlay supports it,
that is, if its B<metadata/layout.conf> Datei contains the line
B<cache-format=md5-dict>.
(Note that only portage reads B<metadata/layout.conf>; eix does not.)
.TP
.BR metadata-assign " or " metadata-assign:I<PATH>
This is similar to B<metadata-flat> with the difference that the Dateis within
the metadata cache are expected to be in an "assignment format"
(TYPE=value) which is the case in some alt-gentoo trees.
.TP
.BR metadata-md5-or-flat ", " metadata-md5-or-flat:I<PATH>
This is similar to B<metadata-flat> with the difference that it is first
attempted to find each category in $PORTDIR/metadata/md5-cache.
If I<PATH> is specified, this method is equivalent to B<metadata-md5>:I<PATH>.
.TP
.BR metadata-md5-or-assign ", " metadata-md5-or-assign:I<PATH>
This is similar to B<metadata-assign> with the difference that it is first
attempted to find each category in $PORTDIR/metadata/md5-cache.
If I<PATH> is specified, this method is equivalent to B<metadata-md5>:I<PATH>.
.TP
.B sqlite
This is an extremely fast cache method if you are using portage with the
sqlite backend, see I<http://en.gentoo-wiki.com/wiki/Portage_SQLite_Cache>
(originally this was described in
I<http://gentoo-wiki.com/TIP_speed_up_portage_with_sqlite>
which might be still accessible at
I<http://gentoo-wiki.info/TIP_speed_up_portage_with_sqlite>).
Note that in contrast to the default B<metadata> cache method you must
use B<emerge --metadata> before you call B<eix-update> with this method.

.RS
Since the support of this cache method requires B<sqlite> to be installed,
this method is not necessarily compiled in.
You must have emerged B<eix> with the appropriate USE flag
(or in a manual installation used I<./configure --with-sqlite>
before compilation) if you want support for this method.

As for all other cache methods, only those categories enabled by
profile/category (in the main tree or some overlay) are read.
If you do not want this, use B<sqlite*> (see below).
.RE
.TP
.B sqlite*
This is analogous to the cache method B<eix> with the difference that
all categories found in I<FILE> are added, even those categories which
were not enabled by some profile/categories Datei.
.TP
.BR flat " or " flat:I<PATH>
This is similar to B<metadata-flat> with the difference that the metadata is
expected in the Verzeichnis I<PATH>I<${PORTAGE_OR_OVERLAY_DIR}>.
If I<PATH> is omitted, it defaults to B</var/cache/edb/dep>.

.RS
You can use this cache method with <portage-2.1 and the default backend.
.RE
.TP
.BR assign " or " assign:I<PATH>
This is analogous to B<flat> with the difference that the Dateis are
expected to be in an "assignment format" (TYPE=value).
This is the case if you use portage-2.1 with the default backend.

.RS
If you are using >=portage-2.1 and the default backend,
you might want to use this one if you do not have access to the portage
tree when you run eix-update.
Note that in contrast to the default B<metadata-*> cache methods you must
run B<emerge --metadata> before you call B<eix-update> with this method.
You will probably want to use a corresponding option in eix-sync in this case.
.RE
.TP
.BR repo-flat " or " repo-flat:I<PATH> " or " repo-assign " or " repo-assign:I<PATH>
This is analogous to B<flat>/B<assign> with the difference that the metadata is
expected in the Verzeichnis I<PATH>B</>I<${repo_name}>.
If I<${repo_name}> is empty, the name B<x->I<XXX> is assumed where I<XXX>
is the last nonzero path component of the portage/overlay Verzeichnis.
This corresponds to the naming scheme of paludis.
If this gives a wrong path for some overlay, you can still manually override
this with e.g.
.BI "OVERRIDE_CACHE_METHOD='" bad_overlay " " metadata-assign ":" correct_path "'".
.TP
.BR parse "[" # metadata-method "]..."
Get the information from the ebuilds, parsing it using some heuristics.
Hence, this method has no security risk but possibly some other problems.
For example, if variables are only set in eclasses, this method will not see them.
Examples of problems with this method is missing SLOT information for
typical ebuilds from kde-base or stupid version numbers for gcc cross-compilers.
This is the cache-method B<none> from older eix versions (before 0.11.1).

.RS
It is optionally possible to append one or several strings of the form
B<#>I<metadata-method> where I<metadata-method> is any of the above mentioned
cache methods (excluding B<sqlite>).
In this case, the metadata-methods are used to check whether they contain
newer information than the ebuild.
If this is the case, the metadata is used instead of the ebuild
(the first matching metadata wins).

Usually this is what you want, especially for overlays, since the metadata
is more reliable than the results of cache method B<parse>.
Of course, this is only useful if the overlay I<foo> contains metadata
which is regularly updated by the overlay maintainer using

.B egencache --repo=I<foo> --update

(whether this is done for layman overlays depends on the overlay maintainer;
for your local overlays you can of course use the above command manually).

Since this is usually what you want, the string in B<CACHE_METHOD_PARSE>
is appended by default to the cache method B<parse>.

Of course, if you know in advance that the metadata information of the
overlay is up-to-date, it is (slightly) faster to use directly to use
the corresponding metadata method (usually B<metadata-flat>).
The latter makes sense if you e.g. call B<egencache> from a script which you
use to sync the overlay (e.g. in eix-sync).
.RE
.TP
.BR parse* "[" # "metadata-method]..."
This is essentially the same as cache method B<parse> with the difference
that variables are not expanded in variable definitions.
This is the cache-method B<none*> from older eix versions (before 0.11.1)
and cache-method B<none> from very old eix versions (before 0.7.1)
.TP
.BR ebuild "[" # "metadata-method]..."
If no portage cache is available (e.g. for overlays)
this is the most compatible but also the slowest method.
The information is obtained via "/usr/bin/ebuild ... depend" from the ebuild.
Since all ebuilds will get executed by bash, this may be a security risk
if you do not trust all ".ebuild" scripts or your environment variables.
Intentionally, the environment is not cleared before the actual execution
so that you can pass further variables to the ebuild.
However, this can also lead to unexpected behaviour or even a security risk
since many bash scripts may be tricked with strange environments.
Use B<env -i eix-update> when this causes problems.

.RS
.B Do not use this method if you do not completely trust all .ebuilds for which the method applies!

Concerning the optional appendices B<#>I<metadata-method>, see the description of the cache method B<parse>.
Note that if corresponding metadata is available this will be essentially faster than executing the ebuild.
.RE
.TP
.BR ebuild* "[" # "metadata-method]..."
This is a slightly faster and slightly less compatible version of B<ebuild>:
The information is obtained via the undocumented "/usr/lib/portage/ebuild.sh".
Thus, instead of executing a python program for each ".ebuild" as for
cache-method B<ebuild>, "only" a lengthy shell-script and the ebuild itself
is executed (hence, also this method is unsafe if you do not trust all
".ebuild" scripts).
Most environment variables except for portage variables and PATH are cleared;
PORTAGE_BIN_PATH and PORTAGE_ROOTPATH are exported (be aware that ebuild.sh
uses these to calculate the PATH, so this may be a severe security issue);
some .ebuild-specific variables like $P are set when the ebuild is executed.
This method is not quite as compatible as the method B<ebuild>, and its
success may depend more on the portage version.
However, this method is considerably faster than B<ebuild> and stable
enough to treat e.g. typical ebuilds from kde-base.

.RS
.B Do not use this method if you do not completely trust all .ebuilds for which the method applies!
.RE
.TP
.BR parse|ebuild ", " parse*|ebuild ", " parse|ebuild* ", " parse*|ebuild*  " [" # "metadata-method]..."
This is a mixture of B<parse>/B<parse*> and B<ebuild>/B<ebuild*>.
Each ebuild is first scanned as with method B<parse>/B<parse*>.
If the obtained result has missing information or appears strange,
the ebuild is treated as with cache method B<ebuild>/B<ebuild*>.
As a rule of thumb, this method is much faster than B<ebuild>/B<ebuild*>
but still much slower than B<parse>/B<parse*>.
It has the same security risks as B<ebuild>/B<ebuild*>, of course.

.RS
.B Do not use this method if you do not completely trust all .ebuilds for which the method applies!
.RE
.TP
.BR eix "  or   "  eix:I<FILE> "  or  " eix:I<FILE>:I<overlay>
Use the cacheDatei I<FILE> previously generated by B<eix-update>.
If omitted or empty, I<FILE> defaults to @EIX_CACHEFILE@.

.RS
As for all other cache methods, only those categories enabled by
profile/category (in the main tree or some overlay) are read.
If you do not want this, use B<eix*> (see below).

If I<overlay> is not given or empty, then only the "main" tree in I<FILE> is read -
overlays within I<FILE> are ignored.
Otherwise only the part corresponding to I<overlay> is read from I<FILE>.
Here, "corresponding" means the first overlay from I<FILE> matching the wildcard pattern I<overlay> is used.
"Matching" means that first the label is tested, then the path and finally also the number
of the overlay within I<FILE>. Note that I<overlay> has in general no relation with the current overlay
names or order - only the names/order stored in I<FILE> play a role here.

There are two exceptional values for I<overlay> which are treated by different rules:

If I<overlay> has the special value "~", then the name of the current overlay label
is used implicitly as the I<overlay> argument;
If the current overlay label is empty or does not match, then the current overlay path is used instead.

If I<overlay> has the special value "*", then B<all> overlays in I<FILE> are read.
Note this is usually not what you want since it means that if I<FILE> originally contained several overlays,
this overlay structure will appear "flattened".
.RE
.TP
.BR eix* "  or   "  eix*:I<FILE> "  or  " eix*:I<FILE>:I<overlay>
This is analogous to the cache method B<eix> with the difference that
all categories found in I<FILE> are added, even those categories which
were not enabled by some profile/categories Datei.

.RS
This cache method is useful if I<FILE> contains information for some
overlay Verzeichnis for which the corresponding profile/categories on
the local machine is unknown or not necessarily up-to-date.

This is used for B<eix-remote>.

Note that in particular with B<PORTDIR_CACHE_METHOD="eix*::~">,
the overlay data is by default just "copied" from the previous eix cacheDatei.
.RE
.RE

.TP
.BR KEEP_VIRTUALS " " (true / false)
If true, eix-update will keep all virtual overlays from the previous database
if that existed.
This has the same effect as appending for each virtual overlay of the previous
database the entry "I<overlay-name>" to B<ADD_OVERLAY> and appending a
corresponding entry "I<overlay> eix*::I<overlay>" to B<CACHE_METHOD>.
Note that this means that this option might override settings made in
B<CACHE_METHOD>, but it might be overridden by settings from
B<OVERRIDE_CACHE_METHOD>.
.TP
.BR REPO_NAMES
This variables is a Stringliste of the form "I<dir-pattern> I<overlay-label> I<dir-pattern> I<overlay-label> ...".
When a new cacheDatei is created, the overlay matching I<dir-pattern> obtains the label I<overlay-label>,
independent of the content of its profiles/repo_name Datei.
This variable can also associate label names to virtual overlays which do not possess such a Datei.
In particular, this variable also overrides overlay labels set by KEEP_VIRTUALS.
Later entries override earlier ones: The last matching entry takes precedence.
.TP
.BR LOCAL_PORTAGE_CONFIG " " (true / false)
If false, /etc/portage and B<ACCEPT_KEYWORDS> (from make.conf or the environment) are ignored.
Since eix-0.7.9, it is recommended to leave this value "true",
because setting it to "false" will just hide some informations.
.TP
.BR ALWAYS_ACCEPT_KEYWORDS " " (true / false)
If true, B<ACCEPT_KEYWORDS> is used even without B<LOCAL_PORTAGE_CONFIG>,
e.g. to determine the `default' stability.
.TP
.BR UPGRADE_LOCAL_MODE " " (+ " or " local / - " or " non-local "/anything else" )
If this variable is B<+> / B<->, the B<--upgrade> option of eix will always
match as if B<LOCAL_PORTAGE_CONFIG> was set to B<true> / B<false>.
.TP
.BR RECOMMEND_LOCAL_MODE " " (+ "  or " local / - " or " non-local "/anything else" )
If this variable is B<+> / B<-> the upgrade/downgrade recommendations
as well as in eix-diff the tests for version changes will act as is
B<LOCAL_PORTAGE_CONFIG> was set to B<true> / B<false>.
.TP
.BR UPGRADE_TO_HIGHEST_SLOT " " (true / false)
If true, all upgrade tests will give a positive result for an installed
package for which not the slot with the best stable version is installed.
Exceptions to this general policy can be specified in
B</etc/portage/package.slot_upgrade_forbid> or
B</etc/portage/package.slot_upgrade_allow>, respectively.
.TP
.BR RECURSIVE_SETS " " (true / false)
If true, then sets and packages which are contained in an included set
are considered as part of the parent set.
.TP
.BR XML_KEYWORDS (full / effective / both / true / full* / effective* / none / false)
With --xml, this variable decides whether full/effective (or both) types of B<KEYWORDS> are printed for each versions.
Here, "full" is the B<KEYWORDS> string as specified in the ebuild and "effective" means its modification by the profile.
The values B<full*>/B<effective*> are similar to B<full>/B<effective>, but both types are printed if their values differ.
B<true>/B<false> are equivalent to B<full*>/B<none>.
.TP
.BR XML_OVERLAY " " (true / false)
With --xml, this variable decides whether the overlay (i.e. its path) is output for each version.
This has no influence for versions from overlays without label (repository name):
For those versions the overlay is output unconditionally.
.TP
.BR SORT_INST_USE_ALPHA " " (true / false)
If B<true>, print the useflags of installed packages in alphabetical order.
Otherwise, first those useflags are printed (in alphabetical order) which
were set when the package was emerged, then the others are printed
(in alphabetical order).
.TP
.BR CHECK_INSTALLED_OVERLAYS " " (true / false / repository)
If B<true>, always check from which overlay a package was installed.
If B<false>, only packages with versions in at least two trees are checked,
i.e. only packages for which it appears reasonable from the database that
it might have been installed from a different overlay.
However, this information might be false if such a package was removed
from an overlay or if a whole overlay is not in the database anymore.

The special value B<repository> is a reasonable compromise:
If repository data was stored during emerge (this is the case only with current
portage versions; you can use B<eix-installed [no-]repository> to check
for which versions this is (not) the case) then this repository data is always used.
Only if it is unreadable or does not match, the behaviour for that version
is the same as in case B<CHECK_INSTALLED_OVERLAYS=false>.

Especially in connection with option -T (if B<NONEXISTENT_IF_OTHER_OVERLAY>
is true) and with option -J the speed increase is enormously if you set this
variable to B<false> or B<repository>, but you should be aware that the
information used about the installed overlay is not completely reliable
(for versions installed with old portage versions).
In particular, the option -T will not detect if an installed version of
a package actually stems from a redundant overlay if in the current database
all versions of this package stem from one (other) location.
.TP
.BR PRINT_COUNT_ALWAYS " " (true / false / never)
If true, always print the number of matches in the last line, even if this
number is 0 or 1.
If B<PRINT_COUNT_ALWAYS=never>, then this last line is omitted completely.
Both is normally not useful but might simplify writing certain scripts
parsing the output of eix.
.TP
.BR COUNT_ONLY_PRINTED " " (true / false)
If false, print only the number of matches, independently of whether the
matches actually lead to some output.
This might be useful for certain scripts if you are only interested in the
number of matches and use e.g. B<FORMAT=''> to speed things up.
.TP
.\" {{{ Default match fields and algorithms
.BR DEFAULT_MATCH_FIELD " " "(Stringliste)"
This is a list of strings of the form I<regular_expression>[\\n\\r\\t ]I<match_field>
which is used to determine the default match field.
The search pattern from the command line is matched against all the I<regular_expression>
values in this list in the given order.
For the first match, the corresponding I<match_field> value is used as the default match field.
You can specify a last I<match_field> (without a I<regular_expression>) in this list which is
used as the default fallback if all matches failed; if there is no such entry, then B<name> is assumed.
It may be convenient to use delayed substitution ${\\VAR} for I<regular_expression>
to avoid manually inserting additional escapes.

The possible values for I<match_field> are B<name>, B<category>, B<category/name>
(or B<category-name>), B<description>, B<license>, B<homepage>, B<set>,
B<slot>, B<installed-slot>, B<use> (or B<iuse>), B<with-use> (or B<installed-with-use>),
B<without-use> (or B<installed-without-use>),
B<deps>, B<depend>, B<rdepend>, B<pdepend>,
corresponding to the analogous command line option for the match field.
.TP
.BR DEFAULT_MATCH_ALGORITHM " " "(Stringliste)"
This is a list of strings of the form I<regular_expression>[\\n\\r\\t ]I<match_algorithm>
which is used to determine the default match algorithm.
This is analogous to B<DEFAULT_MATCH_FIELD> with the only difference that I<match_algorithm>
specifies the default match algorithm chosen.
The possible values for I<match_algorithm> are B<regex>, B<pattern>, B<substring>, B<begin>, B<end>, B<exact>, B<fuzzy>
which correspond to the analogous command line option for the match algorithm.
If no other default match algorithm default is specified, then B<regex> is used.
.TP
.\" }}}
.\" {{{ Definition of Redundancy
.BR TEST_FOR_EMPTY " " (true / false)
Defines whether empty entries in /etc/portage/package.* are shown with -t.
.TP
.BR TEST_KEYWORDS " " (true / false)
Defines whether /etc/portage/package.{accept_,}keywords is tested with -t.
.TP
.BR TEST_MASK " " (true / false)
Defines whether /etc/portage/package.mask is tested with -t.
.TP
.BR TEST_UNMASK " " (true / false)
Defines whether /etc/portage/package.unmask is tested with -t.
.TP
.BR TEST_USE " " (true / false)
Defines whether /etc/portage/package.use is tested with -t.
.TP
.BR TEST_ENV " " (true / false)
Defines whether /etc/portage/package.env is tested with -t.
.TP
.BR TEST_LICENSE " " (true / false)
Defines whether /etc/portage/package.license is tested with -t.
.TP
.BR TEST_CFLAGS " " (true / false)
Defines whether /etc/portage/package.cflags is tested with -t.
.TP
.BR TEST_REMOVED " " (true / false)
Defines whether removed packages are tested with -t.
.TP
.BR TEST_FOR_NONEXISTENT " " (true / false)
Defines whether non-existing installed versions are positive for -T.
What is considered as non-existent is defined by the B<NONEXISTENT_IF>-variables.
.TP
.BR TEST_FOR_REDUNDANCY " " (true / false)
Defines whether redundant entries in /etc/portage/package.* are positive for -T.
What is considered as redundant is defined by the B<REDUNDANT_IF>-variables.
.TP
.BR ACCEPT_KEYWORDS_AS_ARCH " " (full / true / false)
If full or true modify ARCH by ACCEPT_KEYWORDS.
This determines which keywords are considered as ARCH or OTHERARCH.
The value full also influences the original ARCH keywording.
.TP
.BR NONEXISTENT_IF_OTHER_OVERLAY " " (true / false)
Defines whether versions are non-existent for TEST_FOR_NONEXISTENT
if they come from a different overlay than the installed version.
.TP
.BR NONEXISTENT_IF_MASKED " " (true / false)
Defines whether masked versions are non-existent for TEST_FOR_NONEXISTENT.
.TP
.BR REDUNDANT_IF_DOUBLE " " (string)
Applies if /etc/portage/package.{accept_,}keywords lists the same keyword twice
for some/all (un-/installed) versions.

.RS
B<string> describes which versions should be tested.
It can have the following values:
.TP
.BR no " or " false
Do not test for this type of redundancy.
.TP
.B some
It suffices that the redundancy occurs for some version in the database.
.TP
\fBall\fR
The redundancy must occur for all versions in the database.
.TP
.B some-installed
It suffices that the redundancy occurs for some installed version.
Uninstalled versions are ignored for this test.
.TP
.B all-installed
The redundancy must occurs at least for all installed versions of the package.
If no version is installed, it must occur at least once.
.TP
.B some-uninstalled
It suffices that the redundancy occurs for some uninstalled version.
Installed versions are ignored for this test.
.TP
.B all-uninstalled
The redundancy must occurs at least for all uninstalled versions.
If all versions in the database are installed, it must occur at least once.
.TP
.BR "-" "some of the above  or  " "+" "some of the above"
The test only applies if in addition no version (in case B<->)
resp. at least some version (in case B<+>) of the package is installed.
.TP
.RB "some of the above  " or "  some of the above"
The result is positive if at least one of the two tests is positive.
Instead of "B<or>"  also the symbols "B<|>" or "B<||>" can be used.
.RE

.TP
.BR REDUNDANT_IF_DOUBLE_LINE " " (string)
Applies if /etc/portage/package.{accept_,}keywords has two lines for identical targets,
i.e. such that portage would drop the first of these lines.
Note that lines with targets B<foo/bar> and B<=foo/bar-1> are considered as
different in this context by portage (and thus also by eix)
even if B<foo/bar> would apply to version B<1>.
The latter redundancy can be found implicitly with B<REDUNDANT_IF_DOUBLE_LINE>,
B<REDUNDANT_IF_MIXED>, and B<REDUNDANT_IF_STRANGE>.
.TP
.BR REDUNDANT_IF_MIXED " " (string ", see above")
Applies if /etc/portage/package.{accept_,}keywords lists two different keywords,
e.g. ~ARCH and -*, for the versions in question.
.TP
.BR REDUNDANT_IF_WEAKER " " (string ", see above")
Applies if /etc/portage/package.{accept_,}keywords lists a keywords which can
be replaced by a weaker keyword, e.g. -* or ~OTHERARCH or OTHERARCH
in place of ~ARCH, or ~OTHERARCH in place of OTHERARCH,
for the versions in question.
.TP
.BR REDUNDANT_IF_STRANGE " " (string ", see above")
Applies if /etc/portage/package.{accept_,}keywords lists a strange keyword,
e.g. UNKNOWNARCH (unknown to the .ebuild and ARCH) or -OTHERARCH,
for the versions in question.
.TP
.BR REDUNDANT_IF_NO_CHANGE " " (string ", see above")
Applies if /etc/portage/package.{accept_,}keywords provides keywords which do not
change the availability keywords status for the versions in question.
.TP
.BR REDUNDANT_IF_MASK_NO_CHANGE " " (string ", see above")
Applies if /etc/portage/package.mask contains entries
which do not change the mask status for the versions in question.
.TP
.BR REDUNDANT_IF_UNMASK_NO_CHANGE " " (string ", see above")
Applies if /etc/portage/package.unmask contains entries
which do not change the mask status for the versions in question.
.TP
.BR REDUNDANT_IF_DOUBLE_MASKED " " (string ", see above")
Applies if /etc/portage/package.mask matches twice
for the versions in question.
.TP
.BR REDUNDANT_IF_DOUBLE_UNMASKED " " (string ", see above")
Applies if /etc/portage/package.unmask matches twice
for the versions in question.
.TP
.BR REDUNDANT_IF_DOUBLE_USE " " (string ", see above")
Applies if /etc/portage/package.use matches twice
for the versions in question.
.TP
.BR REDUNDANT_IF_DOUBLE_ENV " " (string ", see above")
Applies if /etc/portage/package.env matches twice
for the versions in question.
.TP
.BR REDUNDANT_IF_DOUBLE_LICENSE " " (string ", see above")
Applies if /etc/portage/package.license matches twice
for the versions in question.
.TP
.BR REDUNDANT_IF_DOUBLE_CFLAGS " " (string ", see above")
Applies if /etc/portage/package.cflags matches twice
for the versions in question.
Note that this Datei is not supported by portage, but you might e.g. have built some
support for it in your personal /etc/portage/bashrc Datei.
Of course, this means that also no format for /etc/portage/package.cflags is defined.
eix assumes that the format is analogous to /etc/portage/package.{keywords,use}
(i.e. an entry is at most one line, with the matching version(s) at the beginning).
As the other /etc/portage/package.* Dateis, /etc/portage/package.cflags may also be a Verzeichnis tree;
in this case, all non-hidden Dateien/Unterverzeichnisse in this tree are read recursively,
resolving all symbolic links.
.TP
.BR REDUNDANT_IF_IN_KEYWORDS " " (string ", see above")
Applies if /etc/portage/package.{accept_,}keywords contains a nonempty entry matching the versions in question
(to find empty entries use -t).
Of course, one will certainly not consider all matches as a redundancy
(although one might misuse this option to simply list all matches).
However, one might consider matching but non-installed packages as redundant.
Hence, typically one might want to set this variable to the value B<-some> or the equivalent value B<-some-uninstalled>
(or to B<false> if one thinks that entries for uninstalled packages are "normal" and not redundant).
.TP
.BR REDUNDANT_IF_IN_MASK " " (string ", see above")
This is analogous to B<REDUNDANT_IF_IN_KEYWORDS>, but for /etc/portage/package.mask.
.TP
.BR REDUNDANT_IF_IN_UNMASK " " (string ", see above")
This is analogous to B<REDUNDANT_IF_IN_KEYWORDS>, but for /etc/portage/package.unmask.
.TP
.BR REDUNDANT_IF_IN_USE " " (string ", see above")
This is analogous to B<REDUNDANT_IF_IN_KEYWORDS>, but for /etc/portage/package.use.
.TP
.BR REDUNDANT_IF_IN_ENV " " (string ", see above")
This is analogous to B<REDUNDANT_IF_IN_KEYWORDS>, but for /etc/portage/package.env.
.TP
.BR REDUNDANT_IF_IN_LICENSE " " (string ", see above")
This is analogous to B<REDUNDANT_IF_IN_KEYWORDS>, but for /etc/portage/package.license.
See the above comments about this Datei.
.TP
.BR REDUNDANT_IF_IN_CFLAGS " " (string ", see above")
This is analogous to B<REDUNDANT_IF_IN_KEYWORDS>, but for /etc/portage/package.cflags.
See the above comments about this Datei.
.\" }}}
.\" {{{ Various Datei lists:
.TP
.BR SLOT_UPGRADE_FORBID " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.slot_upgrade_forbid
.TP
.BR SLOT_UPGRADE_ALLOW " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.slot_upgrade_allow
.TP
.BR KEYWORDS_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.{accept_,}keywords.nonexistent
.TP
.BR MASK_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.mask.nonexistent
.TP
.BR UNMASK_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.unmask.nonexistent
.TP
.BR USE_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.use.nonexistent
.TP
.BR ENV_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.env.nonexistent
.TP
.BR LICENSE_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.license.nonexistent
.TP
.BR CFLAGS_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.cflags.nonexistent
.TP
.BR INSTALLED_NONEXISTENT " " "(Stringliste)"
This is a list of Dateinames/dirnames which serve as /etc/portage/package.installed.nonexistent
.TP
.BR PACKAGE_NOWARN " " "(Stringliste)"
This is a list of Dateinames/dirnames which serves as /etc/portage/package.nowarn
.\" }}}
.\" }}}

.\" {{{ /etc/portage/sets.eix
.SS /etc/portage/sets.eix
This is a Verzeichnis analogous to B</etc/portage/sets> (see the portage manpage).
Since portage has some ways to define package sets which are not available for eix,
you can use this Verzeichnis to store (static) sets which you want that eix knows anyway
(e.g. so that set entries in /etc/portage/package.{accept_,}keywords can be treated properly).
.\" }}}

.\" {{{ /etc/portage/package.slot_upgrade*
.SS /etc/portage/package.slot_upgrade_forbid
.SS /etc/portage/package.slot_upgrade_allow
Similarly as all other /etc/portage/package.*, this can be a Datei or Verzeichnis.
The entries of this Datei are of the form "category/name" (separated by newlines).
The corresponding packages are treated as exceptions for B<UPGRADE_TO_HIGHEST_SLOT>.
.\" }}}

.\" {{{ /etc/portage/package.*.nonexistent
.SS /etc/portage/package.{accept_,}keywords.nonexistent
.SS /etc/portage/package.keywords.nonexistent
.SS /etc/portage/package.mask.nonexistent
.SS /etc/portage/package.unmask.nonexistent
.SS /etc/portage/package.use.nonexistent
.SS /etc/portage/package.env.nonexistent
.SS /etc/portage/package.license.nonexistent
.SS /etc/portage/package.cflags.nonexistent
Similarly as /etc/portage/package.*, this can be a Datei or a Verzeichnis.
If an entry (separated by space or newline) matches the first word of a line
in the corresponding /etc/portage/package.* Datei,
this line is excluded from the -t tests (for names not in the database).
You can use this to eliminate certain warning from -t.

.SS /etc/portage/package.installed.nonexistent
This is similar to the other /etc/portage/package.*.nonexistent Dateis/dirs
with the difference that it eliminates messages from -t about installed
packages which had been removed from the database.
The entries of this Datei are of the form "category/name", but you can also
omit the "category/" part (although this is not recommended).
.\" }}}

.\" {{{ /etc/portage/package.nowarn
.SS /etc/portage/package.nowarn
Similarly as /etc/portage/package.*, this can be a Datei or a Verzeichnis.
With this Datei/dir you can switch off test for -T for particular packages.
The format of the Datei is similarly to /etc/portage/package.use with the
difference that you can switch on/off tests.
Exactly those lines apply for which at least one matching version is available.
For example, the lines

.B sys-kernel/*-sources no_change weaker

.B >sys-kernel/hardened-sources-2.6.40 -weaker

in this Datei will cause that -T does not find the package
sys-kernel/*-sources if the only cause for it would be that
B<REDUNDANT_IF_NO_CHANGE> or B<REDUNDANT_IF_WEAKER> is set.
An exception to this rule is only made for B<REDUNDANT_IF_WEAKER> and for
hardened-sources, if the latter is available at least in version 2.6.40.
The order in the Datei plays no role: The "-" always takes precedence if it
occurs somewhere.

You can list a package several times in this Datei; the listed tests are
then cumulative for the corresponding package.

Available tests are
B<in_keywords>, B<no_change>, B<double>, B<mixed>, B<weaker>, B<double_line>,
B<in_mask>, B<mask_no_change>, B<double_masked>,
B<in_unmask>, B<unmask_no_change>, B<double_unmasked>,
B<in_use>, B<double_use>,
B<in_env>, B<double_env>,
B<in_license>, B<double_license>,
B<in_cflags>, B<double_cflags>,
the meaning corresponding to the according B<REDUNDNANT_IF_*> variable.

In addition there are the tests B<nonexistent>, B<masked>, B<other_overlay>
which correspond to the respective variables
B<TEST_FOR_NONEXISTENT>, B<NONEXISTENT_IF_MASKED>, B<NONEXISTENT_IF_OTHER_OVERLAY>.
.\" }}}

.\" {{{ -------- @EIX_CACHEFILE@
.SS @EIX_CACHEFILE@
This is the binary database for eix.
The path can be changed with the B<EIX_CACHEFILE> variable
(which by default honours B<EPREFIX> via delayed reference).
.\" }}}

.\" {{{ -------- @EIX_PREVIOUS@
.SS @EIX_PREVIOUS@
This is the previous version of @EIX_CACHEFILE@, used by eix-diff and eix-sync.
The path can be changed with the B<EIX_PREVIOUS> variable
(which by default honours B<EPREFIX> via delayed reference).
.\" }}}

.\" {{{ -------- @EIX_REMOTEARCHIVE@
.SS @EIX_REMOTEARCHIVE@
This is a local copy of the remote archive, used by eix-remote.
The path can be changed with the B<EIX_REMOTEARCHIVE> variable
(which by default honours B<EPREFIX> via delayed reference).
.\" }}}
.\" }}}

.\" {{{ versionsort
.SH versionsort
B<versionsort> is a helper tool for scripts which serves two purposes.
It cuts the version strings from its arguments or interprets the arguments
themselves as version strings (depending on some heuristics).
Then it outputs the version strings in a sorted order, according to the
portage rules of version sorting.
If there is more than one argument, each version (including the last one)
is followed by a newline.
For example,

.RS
.B versionsort gcc-4.4 4.4_alpha0 sys-devel/gcc-4.05 4.5
.RE

will output

.RS
.B 4.05

.B 4.4_alpha0

.B 4.4

.B 4.5
.RE

If you pass only one argument, eix is more sloppy about the version rules;
even if the version part is not completely correct, it is guaranteed
in this case that the output is string-equal to the version part.
Thus, you can use versionsort with one argument to split the package name
from the version part in a shell script by

.RS
B<split=1-font-adobe-75dpi-1.3-r1>

B<version=`versionsort "X${split}"`; name=${split%"-${version}"}>
.RE

Although currently it makes no difference, it is safer in such a case
(concerning possible future extensions of the version format)
to let the argument(s) start with a non-number (like B<X> in the above example)
to make sure that versionsort will really cut the version from the argument
and cannot misinterpret the whole argument as a version.
.\" }}}


.\" {{{ BUGS
.SH "BUGS (and sort of FAQ)"
.LP
For bugreports use either I<@PACKAGE_BUGREPORT@> or Gentoo's bugzilla I<http://bugs.gentoo.org/>

eix does not and probably never will support dependencies and/or useflags.
In particular, this means that eix -u output will be in general different
from the output of an emerge update command - rely only the latter for your system.
This holds in particular also for the upgrades of packages with slots.
The variable B<UPGRADE_TO_HIGHEST_SLOT> and manual exceptions
in B</etc/portage/package.slot_upgrade_forbid> or
B</etc/portage/package.slot_upgrade_allow>, respectively, can be used to
manually work around some of these shortcomings somewhat.

eix does not and never will fully support all sets which portage does support.
Currently, it appears that even the proposed way of PROPERTIES=set to put
packages in the tree will never be supported by eix (because eix would need
full support for dependencies and useflags to handle these).
As a workaround you can manually define such additional sets in
B</etc/portage/sets.eix>.
Moreover, eix does not and probably never will support reading of sets.conf Dateis.
If you specified additional B<sets/> directories e.g. in some overlay, you must
add these additional directories manually to the B<EIX_LOCAL_SETS> variable
in @SYSCONFDIR@/eixrc.
The easiest way to do the latter is to put an entry like

B<EIX_LOCAL_SETS_ADD=">I</path/to/overlay1/sets> I</path/to/overlay2/sets> I<...>B<">

into @SYSCONFDIR@/eixrc (see the description of B<EIX_LOCAL_SETS> above).

eix-diff does never consider /etc/portage/profile. (Reason: The saved database
contains only the masking state according to the original profile, but not the
profile itself.
On the other hand, /etc/portage/profile can only be interpreted when the
profile is known.)

The output with the default B<OVERLAYS_LIST=all-used-renumbered> is confusing when one wants
to use the overlay number in some eix variable/command-argument.

There is no cache method setting which gets information from overlays
(for which no portage cache metadata is available) fast and reliable -
you must always choose between one of these two extremes.
The default is the fast one, but it shows often false slots and has other problems.

All the B<EPREFIX>/B<ROOT> stuff is confusing.
In particular, by the mere fact of allowing much of these variables,
eix will always be vulnerable to local attacks if it is called with a possibly unsafe environment.

The previous default B<KEEP_VIRTUALS=true> used to confuse people.
However, with the new default, nobody will find out that this feature exists.
:(

There are too many features: The documentation and configuration has become too complicated.
On the other hand, there are still many things which cannot be configured...
.\" }}}

.\" {{{ HISTORY
.SH "HISTORY"
.LP
B<eix> was formerly known as B<portagedb>. The name was changed because a part of
portage is also called portagedb, which was a bit confusing for everyone.

The functionality of eix-update was once triggered by using the -u switch on eix.
It was than separated to provide better maintainability.
Thus B<update-eix> came to life.
Meanwhile, it is the same executable with functionality distinguished by its call name.
and the original name update-eix was renamed into B<eix-update>.

Also B<eix-diff> was previously called B<diff-eix>,
B<eix-remote> was previously called B<update-eix-remote>,
B<eix-layman> was previously called B<update-eix-layman>, and
B<eix-functions.sh> was previously called B<functions-eix.sh> (and much earlier B<update-eix-functions.sh>).
The reason for all these renamings is to have a more consistent naming scheme:
All programs belonging to eix now start with eix-* (with the exception of
B<versionsort> which is more or less just an independent tool).

If you cannot get accustomed to this new naming scheme or have scripts depending
on the old names, you can use symbolic links for the original names;
this is explicitly supported and is not intended to be deprecated.

Previously, there was a B<./configure> option to install such symlinks
or a reminder about their removal automatically, but this support has been
removed as of eix-0.24.0.

Since the introduction of the %{*VARIABLE} syntax in eix-0.8.0, it is not
reasonable anymore to use different variable names for eix and eix-diff.
Hence, all corresponding B<DIFF_*> variables have vanished.

The cache method B<metadata-flat> was previously just called B<metadata>.
The cache method B<assign> was previously called B<backport> or B<portage-2.1>.
The cache method B<flat> had previously the name B<portage-2.0> which was even preferred.
Anyway, the obsolete names are still supported.

portage-2.1 and portage-2.1.1 doesn't remove the old dep-cache, thus eix might
find packages that are not in portage anymore if the B<flat>/B<assign>
cache method is used.
To circumvent this, eix-sync used to delete the old cache
(rm -rf /var/cache/edb/dep/*).
Since most people have no need to use this cache method anymore and
deleting the old cache slows down the next portage run, this is
not the default anymore (but still available as an option which can be
put into @SYSCONFDIR@/eix-sync.conf).

eix-sync used to default to gensync instead of layman.
See the description of @SYSCONFDIR@/eix-sync.conf how you can still use the
deprecated gensync if you want to.

eix-sync no longer supports logging; options -v and -V have been removed.
This avoids problems like no visible output with EMERGE_DEFAULT_OPTS=--ask.
You should now use redirection when you want to use eix-sync in a cronjob.

The mechanism described now by B<DEFAULT_MATCH_FIELD> has changed.
The previous (less powerful) B<MATCH_.*_IF> and B<MATCH_ORDER> variables
are not supported anymore.

The B<ADD_CACHE_METHOD> and B<ADD_OVERRIDE_CACHE_METHOD> variables are no longer
built-ins but only used implicitly in delayed substitution in the default of
B<CACHE_METHOD> and B<OVERRIDE_CACHE_METHOD>.
In particular, setting the latter variables in B<@SYSCONFDIR@/eixrc> without adding
the delayed substitution " B<%{ADD_CACHE_METHOD}>" or " B<%{ADD_OVERRIDE_CACHE_METHOD}>",
respectively, will prevent the former variables to have any meaning.

Before eix-0.18.0, customizable version output properties like
.BI "<installedversions:" "VAR" ">"
or
.BI "<availableversions:" "VAR" ">"
did not exist.
Instead there was a chaos of parameters for
.B "<installedversions:*>"
and a bulk of variants for printing available or installed versions for
feeding the output to scripts like
.BR "<fullvailableversions>"
etc.
Now all this has vanished: The variables B<NAMEVERSIONS>, B<EQNAMEVERSION>,
B<ANAMESLOT>, B<ANAMEASLOT>, B<NAMESLOT>, B<NAMEASLOT>, and B<DATESORT>
take the role of all the earlier variants (where B<DATESORT> demonstrates
a related example that was previously not available).
See the description of these variables in B<eix --dump> for details.
To see the effect of such an example try e.g.

.B eix --format '<availableversions:ANAMESLOT:ANAMESLOT>' --pure-packages gcc

See also the comments for the B<-I> option.

Since eix-0.20.0 the logical connectives for AUSDRUCK have changed dramatically:
Not only braces are now possible, also chains with B<-a> and B<-o> are now treated
left-associative as most users would intuitively expect.
The negation B<--not> is now treated as a logical operation starting a new KLAMMER_ODER_TEST
and no longer considered as part of TEST_OPTIONEN (which was a source of confusion for many users).
Now B<--pipe> is really handled as part of TEST_OPTIONEN and does not implicitly introduce logical connectives.

With eix-0.20.1 all the previously used Dateis /etc/portage/package.*.nowarn
are no longer supported by default: They were replaced by the single Datei/dir
/etc/portage/package.nowarn. If you still want to use the previous Dateis, set
B<OBSOLETE_NOWARN=true> in the environment. See the description of the variable
B<PACKAGE_NOWARN> (in the output of B<eix --dump>) to understand why this works.

B<eix-installed> was part of B<eix-test-obsolete> before eix-0.22.4 which was
rather confusing for users and for maintaining, since their task has nothing in common.

The default error-behavior of B<eix-sync> has changed in eix-0.23.10:
Previously, the B<-F> option was automatic and could not be disabled.
.\" }}}

.\" {{{ AUTHORS
.SH "AUTHORS"
.LP

Martin Väth <vaeth at mathematik.uni-wuerzburg.de> (developer, current maintainer)

Emil Beinroth <emilbeinroth at gmx.net> (developer, previous maintainer)


Wolfgang Frisch <xororand at users.sourceforge.net> (inactive developer, initial author)

Roland Wittmann <linuxcommando at users.sourceforge.net> (inactive developer)
.\" }}}

.\" {{{ SEE ALSO
.SH "SEE ALSO"
.BR portage (5),
.\" Match-algorithms
.BR fnmatch (3),
.BR regex (7),
.\" Other search-utils
.BR emerge (1),
.BR esearch (1),
.BR qsearch (1),
.\" Related software .. e.g. stuff we use
.BR layman (8)
.LP
The eix homepage I<@PACKAGE_URL@> provides further information and links.
.\" }}}
.\" vim:set tw=90 expandtab foldenable foldmethod=marker foldlevel=0 :
